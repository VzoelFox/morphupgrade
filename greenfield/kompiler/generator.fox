# greenfield/kompiler/generator.fox
# Modul Generator: Helper untuk emisi bytecode dan manajemen scope

dari "greenfield/cotc/stdlib/core.fox" ambil_sebagian panjang, tambah, tipe_objek, teks, tulis

# === Manajemen Scope ===

fungsi tambah_lokal(ctx, nama) maka
    jika panjang(ctx.lokal_scope) > 0 maka
            biar top_scope = ctx.lokal_scope[panjang(ctx.lokal_scope) - 1]
            ubah top_scope[nama] = benar
    akhir
akhir

fungsi cek_lokal(ctx, nama) maka
    jika panjang(ctx.lokal_scope) > 0 maka
            biar top_scope = ctx.lokal_scope[panjang(ctx.lokal_scope) - 1]
            jika top_scope.punya(nama) maka
                kembali benar
            akhir
    akhir
    kembali salah
akhir

# Helper baru: dapatkan_jenis_var
# Mengembalikan "LOCAL", "CELL", "FREE", atau "GLOBAL"
fungsi dapatkan_jenis_var(ctx, nama) maka
    # 1. Cek Analisis Info (Prioritas untuk Cell/Free)
    jika ctx.info_analisis != nil dan ctx.current_func_node != nil maka
        biar info = nil
        # Debug Indexing
        # tulis("DEBUG GET INFO: " + teks(ctx.info_analisis) + " KEY: " + teks(ctx.current_func_node))

        # Coba akses aman
        # Masalah: StandardVM dict index d[k] jika k object bisa error jika hash beda?
        # Atau jika key tidak ada -> KeyError (Host) -> Panic VM
        # Kita harusnya pakai .punya?
        # Tapi info_analisis adalah Dictionary. .punya bekerja.

        # if ctx.info_analisis.punya(ctx.current_func_node) ...
        # StandardVM .punya implementation for dict works.

        # Tapi jika langsung akses [key], error jika missing.
        # Dan error VM tadi adalah NoneType subscriptable.

        # Jika ctx.info_analisis adalah NIL?
        # Checked != nil above.

        # Jika info_analisis[key] returns NIL?
        # Morph dict access returns nil if key missing?
        # Native VM LOAD_INDEX on dict: obj[idx].
        # Host Dict: raises KeyError.

        # Jadi akses langsung berbahaya jika key tidak ada.

        # Assuming analysis works, key should exist if node visited.

        # Placeholder return for now
        pass
    akhir

    # 2. Cek Lokal (Jika sudah didefinisikan sebelumnya)
    jika cek_lokal(ctx, nama) maka
        kembali "LOCAL"
    akhir

    # 3. Default Global
    kembali "GLOBAL"
akhir

fungsi konteks_saat_ini(ctx) maka
    tulis("DEBUG CTX: " + teks(ctx))
    tulis("DEBUG TUMPUKAN: " + teks(ctx.tumpukan_konteks))

    biar idx = panjang(ctx.tumpukan_konteks) - 1
    biar k = ctx.tumpukan_konteks[idx]
    jika k == nil maka tulis("DEBUG KONTEKS NIL! IDX: " + teks(idx)) akhir
    kembali k
akhir

# === Emisi Bytecode ===

fungsi emit(ctx, op, arg) maka
    biar konteks = konteks_saat_ini(ctx)
    tambah(konteks["instruksi"], [op, arg])
    kembali panjang(konteks["instruksi"]) - 1
akhir

fungsi emit_jump(ctx, op) maka
    kembali emit(ctx, op, -1)
akhir

fungsi patch_jump(ctx, lokasi_jump, target) maka
    biar konteks = konteks_saat_ini(ctx)
    biar instruksi = konteks["instruksi"]

    jika target == nil maka
        ubah target = panjang(instruksi)
    akhir

    biar instr_lama = instruksi[lokasi_jump]
    biar op_kode = instr_lama[0]
    ubah instruksi[lokasi_jump] = [op_kode, target]
akhir

# === Utilitas ===

fungsi dapatkan_tipe(obj) maka
    # tulis("DEBUG TIPE FOR: " + teks(obj))
    coba
        biar k = obj.__class__
        # tulis("KLAS: " + teks(k))
        biar n = k.name
        # tulis("NAME: " + teks(n))
        kembali n
    tangkap e
        # tulis("FALLBACK TIPE: " + teks(e))
        kembali tipe_objek(obj)
    akhir
akhir
