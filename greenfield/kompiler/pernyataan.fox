# greenfield/kompiler/pernyataan.fox
# Modul Pernyataan: Kompilasi node statement

ambil_semua "greenfield/kompiler/generator.fox" sebagai Gen
dari "greenfield/cotc/stdlib/core.fox" ambil_sebagian panjang, tambah, pop, teks, tipe_objek

# --- Implemented Visitors for 'Hello Dek' & Variables ---

fungsi kunjungi_Bagian(ctx, node) maka
    # Bagian adalah list pernyataan (block)
    biar i = 0
    selama i < panjang(node.daftar_pernyataan) maka
        ctx._kunjungi(node.daftar_pernyataan[i])
        ubah i = i + 1
    akhir
akhir

fungsi kunjungi_Tulis(ctx, node) maka
    # node.argumen adalah list ekspresi
    biar i = 0
    selama i < panjang(node.argumen) maka
        ctx._kunjungi(node.argumen[i])
        ubah i = i + 1
    akhir
    Gen.emit(ctx, ctx.Op["PRINT"], panjang(node.argumen))
akhir

fungsi kunjungi_PernyataanEkspresi(ctx, node) maka
    ctx._kunjungi(node.ekspresi)
    Gen.emit(ctx, ctx.Op["POP"], nil)
akhir

fungsi kunjungi_DeklarasiVariabel(ctx, node) maka
    # 'biar nama = nilai'

    # 1. Evaluasi Nilai (jika ada)
    jika node.nilai != nil maka
        ctx._kunjungi(node.nilai)
    lain
        # Jika tidak ada nilai, default ke nil?
        # Atau error? Morph biasanya mengharuskan inisialisasi atau nil.
        Gen.emit(ctx, ctx.Op["PUSH_CONST"], nil)
    akhir

    # 2. Simpan ke Variabel
    # Kita perlu tahu scope variabel (Local vs Global).
    # Gunakan helper dari generator.fox

    biar jenis_var = Gen.dapatkan_jenis_var(ctx, node.nama.nilai)

    jika jenis_var == "LOCAL" maka
        Gen.emit(ctx, ctx.Op["STORE_LOCAL"], node.nama.nilai)
        # Register lokal di scope compiler agar akses berikutnya tahu ini lokal
        Gen.tambah_lokal(ctx, node.nama.nilai)

    # FIX: Handle Closure Cell (Variable declared here, used in inner function)
    lain jika jenis_var == "CELL" maka
        Gen.emit(ctx, ctx.Op["STORE_DEREF"], node.nama.nilai)
        # Cell var juga dianggap "lokal" dalam konteks visibility block ini
        Gen.tambah_lokal(ctx, node.nama.nilai)

    lain
        # Default GLOBAL
        Gen.emit(ctx, ctx.Op["STORE_VAR"], node.nama.nilai)
    akhir
akhir

fungsi kunjungi_Assignment(ctx, node) maka
    # 'nama = nilai' atau 'obj[idx] = nilai'

    biar tipe_target = Gen.dapatkan_tipe(node.target)

    jika tipe_target == "Identitas" maka
        # Kasus 1: Assignment Variabel Biasa
        # Evaluasi nilai dulu
        ctx._kunjungi(node.nilai)

        biar nama = node.target.nama
        biar jenis = Gen.dapatkan_jenis_var(ctx, nama)

        jika jenis == "LOCAL" maka
            Gen.emit(ctx, ctx.Op["STORE_LOCAL"], nama)
        lain jika jenis == "CELL" maka
            Gen.emit(ctx, ctx.Op["STORE_DEREF"], nama)
        lain jika jenis == "FREE" maka
            Gen.emit(ctx, ctx.Op["STORE_DEREF"], nama)
        lain
            Gen.emit(ctx, ctx.Op["STORE_VAR"], nama)
        akhir

    lain jika tipe_target == "Akses" maka
        # Kasus 2: Assignment Index/Map (a[b] = c)
        # Urutan stack yang dibutuhkan STORE_INDEX: [Target, Index, Value] (Value paling atas)

        # 1. Evaluasi Target (objek/peta)
        ctx._kunjungi(node.target.objek)

        # 2. Evaluasi Index (kunci)
        ctx._kunjungi(node.target.kunci)

        # 3. Evaluasi Nilai (value)
        ctx._kunjungi(node.nilai)

        # 4. Emit STORE_INDEX
        Gen.emit(ctx, ctx.Op["STORE_INDEX"], nil)

    lain
        # Assignment kompleks lain (STORE_ATTR) belum didukung
        tulis("[Kompiler] Error: Assignment target tidak didukung: " + tipe_target)
    akhir
akhir

# --- Implementasi Kontrol Alur: JikaMaka ---

fungsi kunjungi_JikaMaka(ctx, node) maka
    biar exit_jumps = []

    # A. IF Utama
    ctx._kunjungi(node.kondisi)
    biar jump_false = Gen.emit_jump(ctx, ctx.Op["JMP_IF_FALSE"])

    ctx._kunjungi(node.blok_maka)
    biar jmp = Gen.emit_jump(ctx, ctx.Op["JMP"])
    tambah(exit_jumps, jmp)

    Gen.patch_jump(ctx, jump_false, nil) # Target: Next check

    # B. Elif (Rantai Lain Jika)
    biar i = 0
    selama i < panjang(node.rantai_lain_jika) maka
        biar pasangan = node.rantai_lain_jika[i]
        ctx._kunjungi(pasangan[0]) # Kondisi
        biar j_false = Gen.emit_jump(ctx, ctx.Op["JMP_IF_FALSE"])

        ctx._kunjungi(pasangan[1]) # Blok
        biar j_end = Gen.emit_jump(ctx, ctx.Op["JMP"])
        tambah(exit_jumps, j_end)

        Gen.patch_jump(ctx, j_false, nil) # Target: Next check
        ubah i = i + 1
    akhir

    # C. Else (Blok Lain)
    jika node.blok_lain != nil maka
        ctx._kunjungi(node.blok_lain)
    akhir

    # D. Patch Semua Exit Jumps ke Sini (Akhir Statement)
    biar k = 0
    selama k < panjang(exit_jumps) maka
        Gen.patch_jump(ctx, exit_jumps[k], nil)
        ubah k = k + 1
    akhir
akhir

# --- Implementasi Loop: Selama (While) ---

fungsi kunjungi_Selama(ctx, node) maka
    # 1. Tandai Label Mulai (Loop Start)
    biar start_label = Gen.label_saat_ini(ctx)

    # 2. Kompilasi Kondisi
    ctx._kunjungi(node.kondisi)

    # 3. Jump If False ke Akhir
    biar jump_end = Gen.emit_jump(ctx, ctx.Op["JMP_IF_FALSE"])

    # 4. Push Loop Block ke Context (untuk Break/Continue nanti)
    # TODO: Implementasi stack loop

    # 5. Kompilasi Badan Loop
    ctx._kunjungi(node.badan)

    # 6. Jump Balik ke Awal
    Gen.emit(ctx, ctx.Op["JMP"], start_label)

    # 7. Patch Jump End
    Gen.patch_jump(ctx, jump_end, nil)
akhir

# --- Implementasi Return ---

fungsi kunjungi_PernyataanKembalikan(ctx, node) maka
    jika node.nilai != nil maka
        ctx._kunjungi(node.nilai)
    lain
        Gen.emit(ctx, ctx.Op["PUSH_CONST"], nil)
    akhir
    Gen.emit(ctx, ctx.Op["RET"], nil)
akhir


# --- Stubs (To Be Implemented) ---

fungsi kunjungi_Lemparkan(ctx, node) maka
    ctx._kunjungi(node.ekspresi)
    Gen.emit(ctx, ctx.Op["THROW"], nil)
akhir

fungsi kunjungi_Pilih(ctx, node) maka
    kembali nil
akhir

fungsi kunjungi_Berhenti(ctx, node) maka
    kembali nil
akhir

fungsi kunjungi_Lanjutkan(ctx, node) maka
    kembali nil
akhir

# === Import ===

fungsi _nama_modul_dari_path(path) maka
    biar p = panjang(path)
    biar i = p - 1
    selama i >= 0 maka
        jika path[i] == "/" maka
            kembali path[(i+1):p]
        akhir
        ubah i = i - 1
    akhir
    kembali path
akhir

fungsi _simpan_ke_variabel_baru(ctx, nama) maka
    biar jenis = Gen.dapatkan_jenis_var(ctx, nama)
    jika jenis == "LOCAL" maka
        Gen.emit(ctx, ctx.Op["STORE_LOCAL"], nama)
        Gen.tambah_lokal(ctx, nama)
    lain jika jenis == "CELL" maka
        Gen.emit(ctx, ctx.Op["STORE_DEREF"], nama)
        Gen.tambah_lokal(ctx, nama)
    lain
        Gen.emit(ctx, ctx.Op["STORE_VAR"], nama)
    akhir
akhir

fungsi kunjungi_AmbilSemua(ctx, node) maka
    # ambil_semua "path/modul" sebagai Alias
    # Opcode: IMPORT <path>

    biar path_str = node.path_file.nilai
    Gen.emit(ctx, ctx.Op["IMPORT"], path_str)

    biar nama_var = nil
    jika node.alias != nil maka
        ubah nama_var = node.alias.nilai
    lain
        ubah nama_var = _nama_modul_dari_path(path_str)
    akhir

    _simpan_ke_variabel_baru(ctx, nama_var)
akhir

fungsi kunjungi_AmbilSebagian(ctx, node) maka
    # dari "path/modul" ambil_sebagian A, B

    # 1. Import Module (Push to Stack)
    biar path_str = node.path_file.nilai
    Gen.emit(ctx, ctx.Op["IMPORT"], path_str)

    # 2. Ambil Atribut
    biar i = 0
    selama i < panjang(node.daftar_simbol) maka
        biar token_nama = node.daftar_simbol[i]
        biar nama = token_nama.nilai

        Gen.emit(ctx, ctx.Op["DUP"], nil) # Copy Modul
        Gen.emit(ctx, ctx.Op["LOAD_ATTR"], nama) # Load Attr dari Modul
        _simpan_ke_variabel_baru(ctx, nama) # Simpan ke Var Lokal/Global

        ubah i = i + 1
    akhir

    # 3. Buang Object Modul dari Stack
    Gen.emit(ctx, ctx.Op["POP"], nil)
akhir

fungsi kunjungi_Pinjam(ctx, node) maka
    # pinjam "builtins" sebagai py

    biar path_str = node.path_file.nilai
    Gen.emit(ctx, ctx.Op["IMPORT_NATIVE"], path_str)

    biar nama_var = nil
    jika node.alias != nil maka
        ubah nama_var = node.alias.nilai
    lain
        ubah nama_var = _nama_modul_dari_path(path_str)
    akhir

    _simpan_ke_variabel_baru(ctx, nama_var)
akhir

# === Kompleks (Jodohkan & Coba) ===

fungsi kunjungi_CobaTangkap(ctx, node) maka
    # 1. PUSH_TRY (dengan placeholder)
    biar push_try_idx = Gen.emit_jump(ctx, ctx.Op["PUSH_TRY"])

    # 2. Blok Coba
    ctx._kunjungi(node.blok_coba)

    # 3. POP_TRY & JMP End
    Gen.emit(ctx, ctx.Op["POP_TRY"], nil)
    biar jump_end_idx = Gen.emit_jump(ctx, ctx.Op["JMP"])

    # 4. Blok Tangkap (Handler)
    # Patch PUSH_TRY ke sini
    Gen.patch_jump(ctx, push_try_idx, nil)

    # Iterasi Daftar Tangkap (Ambil yang pertama saja untuk saat ini - Catch All)
    jika panjang(node.daftar_tangkap) > 0 maka
        biar tangkap_node = node.daftar_tangkap[0]

        # Simpan exception ke variabel (jika ada)
        jika tangkap_node.nama_error != nil maka
            biar nama_var = tangkap_node.nama_error.nilai
            biar jenis = Gen.dapatkan_jenis_var(ctx, nama_var)
            jika jenis == "LOCAL" maka
                Gen.emit(ctx, ctx.Op["STORE_LOCAL"], nama_var)
            lain jika jenis == "CELL" maka
                Gen.emit(ctx, ctx.Op["STORE_DEREF"], nama_var)
            lain
                Gen.emit(ctx, ctx.Op["STORE_VAR"], nama_var)
            akhir
        lain
            # Pop exception object
            Gen.emit(ctx, ctx.Op["POP"], nil)
        akhir

        ctx._kunjungi(tangkap_node.badan)
    lain
        # Jika tidak ada blok tangkap (misal hanya akhirnya?), pop error
        Gen.emit(ctx, ctx.Op["POP"], nil)
    akhir

    # 5. End
    # Patch JMP End ke sini
    Gen.patch_jump(ctx, jump_end_idx, nil)
akhir

fungsi kunjungi_Jodohkan(ctx, node) maka
    kembali nil
akhir
