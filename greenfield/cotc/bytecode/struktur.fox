# greenfield/cotc/bytecode/struktur.fox
# Definisi ObjekKode dan Serialisasi Format "VZOEL FOXS"

ambil_semua "greenfield/cotc/bytes.fox" sebagai B
pinjam "time" sebagai time
dari "greenfield/cotc/stdlib/core" ambil_sebagian int, float, panjang, tipe_objek
pinjam "builtins" sebagai py

kelas ObjekKode maka
    fungsi inisiasi(nama, instruksi, argumen, konstanta) maka
        ini.nama = nama
        ini.instruksi = instruksi # List of [opcode, arg]
        ini.argumen = argumen     # List of strings
        ini.konstanta = konstanta # List of values
    akhir

    fungsi serialisasi() maka
        biar buf = B.buat_buffer()

        # --- HEADER (16 Bytes) ---
        # MAGIC: "VZOEL FOXS" (10 bytes)
        B.tulis_buffer(buf, "VZOEL FOXS".encode("utf-8"))

        # VER: 0x01 (1 byte)
        B.tulis_buffer(buf, B.pack_byte(1))

        # FLAGS: 0x00 (1 byte)
        B.tulis_buffer(buf, B.pack_byte(0))

        # TIMESTAMP: Unix Time (4 bytes int)
        biar ts = int(time.time())
        B.tulis_buffer(buf, B.pack_int(ts))

        # --- DATA BLOCK (Main Code Object) ---
        ini._tulis_code_object(buf, ini)

        kembali B.buffer_ke_bytes(buf)
    akhir

    fungsi _tulis_code_object(buf, co) maka
        # Tag CodeObject (0x07)
        B.tulis_buffer(buf, B.pack_byte(7))

        # Nama
        B.tulis_buffer(buf, B.pack_string(co.nama))

        # Arg Count
        B.tulis_buffer(buf, B.pack_byte(panjang(co.argumen)))

        # Arg Names
        biar i = 0
        selama i < panjang(co.argumen) maka
            B.tulis_buffer(buf, B.pack_string(co.argumen[i]))
            ubah i = i + 1
        akhir

        # Constants Pool
        # Format: [Count 4bytes] + [Items...]
        # Di sini kita perlu strategi. Kompiler saat ini menyimpan konstanta di PUSH_CONST argumen.
        # Untuk format biner yang efisien, instruksi harus merujuk ke index pool.
        # TAPI, untuk tahap awal, kita simpan instruksi "apa adanya" (OP, ARG)
        # dan simpan nilai ARG di stream instruksi.
        # Ini menyimpang dari struktur ideal "Code Object" standar (JVM/Python),
        # tapi lebih mudah diimplementasikan tanpa merombak total kompiler hari ini.
        # REVISI: Mari kita coba mendekati ideal.
        # Kita simpan konstanta di pool.

        B.tulis_buffer(buf, B.pack_int(panjang(co.konstanta)))
        ubah i = 0
        selama i < panjang(co.konstanta) maka
            ini._tulis_konstanta(buf, co.konstanta[i])
            ubah i = i + 1
        akhir

        # Instructions
        # Format: [Count 4bytes] + [Opcode 1byte + ArgIndex 4bytes] ...
        # ArgIndex merujuk ke Constants Pool jika Opcode butuh konstanta?
        # Atau ArgIndex adalah nilai mentah (int)?
        # Kompiler `kompiler.fox` saat ini menghasilkan: `[OP, ARG]`.
        # ARG bisa berupa: Integer, String, CodeObject (anak), None.
        # Kita perlu menormalisasi ini.

        B.tulis_buffer(buf, B.pack_int(panjang(co.instruksi)))
        ubah i = 0
        selama i < panjang(co.instruksi) maka
            biar op = co.instruksi[i][0]
            biar arg = co.instruksi[i][1]

            # Tulis Opcode (1 byte)
            B.tulis_buffer(buf, B.pack_byte(op))

            # Tulis Argumen (Payload bervariasi tergantung Opcode?)
            # Untuk simplifikasi V1: Kita tulis argumen sebagai Typed Value langsung di stream.
            # Ini tidak se-efisien bytecode murni, tapi sangat fleksibel.
            ini._tulis_konstanta(buf, arg)

            ubah i = i + 1
        akhir
    akhir

    fungsi _tulis_konstanta(buf, val) maka
        # Type Dispatcher
        biar t = py.type(val)

        jika val == nil maka
            B.tulis_buffer(buf, B.pack_byte(1)) # NIL
        lain
            jika t == py.bool maka
                B.tulis_buffer(buf, B.pack_byte(2)) # BOOL
                biar b = 0
                jika val maka
                    ubah b = 1
                akhir
                B.tulis_buffer(buf, B.pack_byte(b))
            lain
                jika t == py.int maka
                    B.tulis_buffer(buf, B.pack_byte(3)) # INT
                    B.tulis_buffer(buf, B.pack_int(val))
                lain
                    jika t == py.float maka
                        B.tulis_buffer(buf, B.pack_byte(4)) # FLOAT
                        B.tulis_buffer(buf, B.pack_float(val))
                    lain
                        jika t == py.str maka
                            B.tulis_buffer(buf, B.pack_byte(5)) # STRING
                            B.tulis_buffer(buf, B.pack_string(val))
                        lain
                            jika t == py.list maka
                                # List biasa (bukan CodeObject)
                                B.tulis_buffer(buf, B.pack_byte(6)) # LIST
                                B.tulis_buffer(buf, B.pack_int(panjang(val)))
                                biar j = 0
                                selama j < panjang(val) maka
                                    ini._tulis_konstanta(buf, val[j])
                                    ubah j = j + 1
                                akhir
                            lain
                                jika t == py.dict maka
                                    # Cek apakah ini definisi CodeObject?
                                    # Kompiler lama menghasilkan dict untuk fungsi anak.
                                    # Tapi kita akan ubah Kompiler untuk hasilkan ObjekKode.
                                    # Jadi ini mungkin Kamus literal biasa.
                                    B.tulis_buffer(buf, B.pack_byte(8)) # DICT (New Type 8)
                                    B.tulis_buffer(buf, B.pack_int(panjang(val)))
                                    # Iterate keys? Python dict iteration in Morph?
                                    # val.items() -> list of tuples
                                    # FFI to lists
                                    biar items = list(val.items())
                                    biar j = 0
                                    selama j < panjang(items) maka
                                        ini._tulis_konstanta(buf, items[j][0]) # Key
                                        ini._tulis_konstanta(buf, items[j][1]) # Value
                                        ubah j = j + 1
                                    akhir
                                lain
                                    # Cek instance ObjekKode
                                    # FFI check type?
                                    # Asumsi jika punya metode 'serialisasi'
                                    # Atau cek nama kelas.
                                    # Cek manual karena try-tangkap mungkin belum stabil sepenuhnya
                                    # atau properti __class__
                                    coba
                                        jika val.__class__.name == "ObjekKode" maka
                                            ini._tulis_code_object(buf, val)
                                            kembali
                                        akhir
                                    tangkap e
                                        # Abaikan error akses properti
                                    akhir

                                    # Fallback
                                    # raise Error("Tipe tidak didukung serialisasi: " + str(type(val)))
                                    # Tulis NIL agar tidak crash
                                    B.tulis_buffer(buf, B.pack_byte(1))
                                akhir
                            akhir
                        akhir
                    akhir
                akhir
            akhir
        akhir
    akhir
akhir
