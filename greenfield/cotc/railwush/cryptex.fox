# greenfield/cotc/railwush/cryptex.fox
# Library Kriptografi Morph Railwush (Pure Morph / Native Stdlib)
# Menggantikan 'netbase/crypto.fox' yang menggunakan cryptography.fernet

dari "greenfield/cotc/stdlib/hashlib" ambil_sebagian sha256_hexdigest
dari "greenfield/cotc/data/base64" ambil_sebagian enkode_bytes, dekode_bytes
dari "greenfield/cotc/stdlib/core" ambil_sebagian panjang, teks, int, chr, ord, gabung, tambah, tipe_objek
pinjam "datetime" sebagai datetime
pinjam "platform" sebagai platform
pinjam "os" sebagai os

# Konstanta
tetap CHECKSUM_FILE = "greenfield/cotc/railwush/checksum.dat"

# Helper untuk Checksum Counter
fungsi _baca_checksum() maka
    coba
        # Menggunakan pinjam builtins untuk buka file sederhana (bisa diganti io/berkas nanti)
        pinjam "builtins" sebagai py
        jika os.path.exists(CHECKSUM_FILE) maka
            biar f = py.open(CHECKSUM_FILE, "r")
            biar konten = f.read()
            f.close()
            kembali int(konten.strip())
        lain
            kembali 1
        akhir
    tangkap e
        kembali 1
    akhir
akhir

fungsi _tulis_checksum(nilai_baru) maka
    coba
        pinjam "builtins" sebagai py
        # Pastikan direktori ada
        biar dir = os.path.dirname(CHECKSUM_FILE)
        jika (dir != "") dan (tidak os.path.exists(dir)) maka
            os.makedirs(dir)
        akhir

        biar f = py.open(CHECKSUM_FILE, "w")
        f.write(teks(nilai_baru))
        f.close()
    tangkap e
        # Abaikan error tulis checksum untuk sementara (non-critical)
        pass
    akhir
akhir

fungsi buat_token_baru() maka
    biar sekarang = datetime.datetime.now()
    biar tanggal = sekarang.strftime("%Y%m%d")
    biar jam = sekarang.strftime("%H%M%S")
    biar perangkat = platform.system().lower()

    biar nomor_akun = _baca_checksum()
    _tulis_checksum(nomor_akun + 1)

    biar abjad = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    # Modulo untuk indeks abjad
    biar idx = (nomor_akun - 1) % 26
    biar char_abjad = abjad[idx : idx+1]

    biar checksum = teks(nomor_akun) + char_abjad

    # Token format: morph-YYYMMDD-HHMMSS-Check-OS
    biar token = "morph-" + tanggal + "-" + jam + "-" + checksum + "-" + perangkat
    kembali token
akhir

fungsi hash_token_ke_namafile(token) maka
    # Gunakan SHA256 hexdigest
    biar hash_val = sha256_hexdigest(token)
    kembali hash_val + ".mnet"
akhir

# --- Implementasi Enkripsi Ringan (XOR Cipher) ---
# Tujuannya adalah mengaburkan data profil tanpa dependensi eksternal.
# Keamanan: Rendah (Obfuscation), tapi cukup untuk 'self-hosted' prototype.

fungsi _xor_cipher(data_bytes, kunci_bytes) maka
    biar hasil = []
    biar len_data = panjang(data_bytes)
    biar len_kunci = panjang(kunci_bytes)
    biar i = 0

    selama i < len_data maka
        biar b = data_bytes[i]
        biar k = kunci_bytes[i % len_kunci]
        # XOR operation
        biar x = b ^ k
        tambah(hasil, x)
        ubah i = i + 1
    akhir

    kembali hasil
akhir

fungsi _string_ke_bytes(s) maka
    # FFI ke string.encode python (native VM support string methods)
    biar b = s.encode("utf-8")
    # Konversi bytes object ke list of int
    biar lst = []
    biar i = 0
    biar l = panjang(b)
    selama i < l maka
        tambah(lst, b[i])
        ubah i = i + 1
    akhir
    kembali lst
akhir

fungsi _bytes_ke_string(lst) maka
    # Manual decode dari list int ke string utf-8
    # Atau gunakan stdlib base64 helper _utf8_decode kalau ada akses
    # Kita pakai pinjam bytes() python biar cepat
    pinjam "builtins" sebagai py
    biar b_obj = py.bytes(lst)
    kembali b_obj.decode("utf-8")
akhir

fungsi enkripsi_data(data_string, token) maka
    # 1. Buat kunci dari token (SHA256 digest -> bytes)
    biar kunci_hex = sha256_hexdigest(token)
    biar kunci_bytes = _string_ke_bytes(kunci_hex)

    # 2. Konversi data ke bytes
    biar data_bytes = _string_ke_bytes(data_string)

    # 3. Lakukan XOR
    biar encrypted_bytes = _xor_cipher(data_bytes, kunci_bytes)

    # 4. Encode hasil ke Base64 (agar bisa disimpan/dikirim sebagai teks aman)
    # Gunakan library base64 native kita (terima list int, return string)
    kembali enkode_bytes(encrypted_bytes)
akhir

fungsi dekripsi_data(data_terenkripsi_b64, token) maka
    coba
        # 1. Decode Base64 ke list bytes (int)
        # data_terenkripsi_b64 harus string base64
        biar encrypted_bytes = dekode_bytes(data_terenkripsi_b64)

        # 2. Buat kunci yang sama
        biar kunci_hex = sha256_hexdigest(token)
        biar kunci_bytes = _string_ke_bytes(kunci_hex)

        # 3. Lakukan XOR lagi (XOR is symmetric)
        biar decrypted_bytes = _xor_cipher(encrypted_bytes, kunci_bytes)

        # 4. Konversi kembali ke string
        kembali _bytes_ke_string(decrypted_bytes)
    tangkap e
        tulis("Gagal dekripsi: " + teks(e))
        kembali nil
    akhir
akhir
