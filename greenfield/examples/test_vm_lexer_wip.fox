# greenfield/examples/test_vm_lexer_native.fox
# Tes Menjalankan Lexer Morph di atas Native VM
# Revisi: Fixed Global Injection untuk Native Execution

# --- Imports Host VM ---
ambil_semua "greenfield/fox_vm/prosesor.fox" sebagai Proc
ambil_semua "greenfield/cotc/bytecode/struktur.fox" sebagai S
ambil_semua "greenfield/cotc/bytecode/opkode.fox" sebagai Opc
ambil_semua "greenfield/lx_morph.fox" sebagai LexerModul
ambil_semua "greenfield/morph_t.fox" sebagai T
ambil_semua "greenfield/handler.fox" sebagai H
dari "greenfield/cotc/stdlib/core" ambil_sebagian tulis, teks, tipe_objek, panjang, tambah
dari "greenfield/cotc/stdlib/core.fox" ambil_sebagian gabung, float, int, kunci
dari "greenfield/cotc/stdlib/teks.fox" ambil_sebagian iris
ambil_semua "greenfield/cotc/warna.fox" sebagai Warna

pinjam "builtins" sebagai py
pinjam "operator" sebagai py_op
pinjam "ivm.core.structs" sebagai structs

biar getattr = py.getattr
biar setattr = py.setattr
biar setitem = py_op.setitem
biar getitem = py_op.getitem
biar contains = py_op.contains
biar BoundMethod = structs.BoundMethod
biar MorphInstance = structs.MorphInstance
biar MorphClass = structs.MorphClass
biar callable = py.callable
biar isinstance = py.isinstance

# Method Lookup Logic
fungsi _lookup_method(klass, nama) maka
    biar curr = klass
    selama curr != nil maka
        biar methods = getattr(curr, "methods")
        jika methods.punya(nama) maka
            kembali methods[nama]
        akhir
        ubah curr = getattr(curr, "superclass")
    akhir
    kembali nil
akhir

fungsi _native_getattr(obj, nama) maka
    biar res = nil

    # 1. Coba getattr standar
    coba
        ubah res = getattr(obj, nama)
        kembali res
    tangkap e
        # Lanjut
    akhir

    # 2. Coba MorphInstance Properties
    coba
        biar props = getattr(obj, "properties")
        jika props != nil dan props.punya(nama) maka
            kembali props[nama]
        akhir
    tangkap e
        # Ignore
    akhir

    # 3. Coba Method Lookup (Jika MorphInstance)
    coba
        biar klass = getattr(obj, "klass")
        jika klass != nil maka
            biar method = _lookup_method(klass, nama)
            jika method != nil maka
                # Create BoundMethod
                kembali BoundMethod(obj, method)
            akhir
        akhir
    tangkap e
        # Ignore
    akhir

    kembali nil
akhir

fungsi _native_setattr(obj, nama, nilai) maka
    coba
        kembali setattr(obj, nama, nilai)
    tangkap e
        coba
            biar props = getattr(obj, "properties")
            ubah props[nama] = nilai
        tangkap e2
            pass
        akhir
    akhir
akhir

# Bridge untuk memanggil Host Callable
fungsi _native_call_host(obj, args) maka
    jika isinstance(obj, MorphClass) maka
        biar inst = MorphInstance(obj)
        biar inisiasi_method = nil
        coba
            ubah inisiasi_method = getattr(inst, "inisiasi")
        tangkap e
            ubah inisiasi_method = nil
        akhir

        jika inisiasi_method != nil maka
             _native_call_host(inisiasi_method, args)
        akhir
        kembali inst
    akhir

    biar n = panjang(args)
    jika n == 0 maka kembali obj() akhir
    jika n == 1 maka kembali obj(args[0]) akhir
    jika n == 2 maka kembali obj(args[0], args[1]) akhir
    jika n == 3 maka kembali obj(args[0], args[1], args[2]) akhir
    jika n == 4 maka kembali obj(args[0], args[1], args[2], args[3]) akhir
    jika n == 5 maka kembali obj(args[0], args[1], args[2], args[3], args[4]) akhir
    kembali nil
akhir

fungsi _native_buat_instance(cls) maka
    kembali MorphInstance(cls)
akhir

fungsi _native_is_callable(obj) maka
    jika callable(obj) maka kembali benar akhir
    jika isinstance(obj, MorphClass) maka kembali benar akhir
    kembali salah
akhir

fungsi copy_exports_dict(sumber, target) maka
    biar keys = py.list(sumber)
    biar len_keys = panjang(keys)
    biar i = 0
    selama i < len_keys maka
        biar k = keys[i]
        jika k != "__name__" dan k != "__doc__" dan k != "__package__" dan k != "__loader__" dan k != "__spec__" dan k != "__file__" dan k != "__cached__" dan k != "__builtins__" maka
             biar val = sumber[k]
             setitem(target, k, val)
        akhir
        ubah i = i + 1
    akhir
akhir

fungsi konversi_kode(host_code) maka
    biar name = host_code.name
    biar inst_host = host_code.instructions
    biar inst_native = []

    biar len_inst = panjang(inst_host)
    biar i = 0
    selama i < len_inst maka
        biar op_tuple = inst_host[i]
        biar op = op_tuple[0]
        biar arg = nil
        jika panjang(op_tuple) > 1 maka
            ubah arg = op_tuple[1]
        akhir
        tambah(inst_native, [op, arg])
        ubah i = i + 1
    akhir

    biar args_host = host_code.arg_names
    biar args_native = []
    biar len_args = panjang(args_host)
    biar j = 0
    selama j < len_args maka
        tambah(args_native, args_host[j])
        ubah j = j + 1
    akhir

    kembali S.ObjekKode(name, inst_native, args_native, [])
akhir

fungsi setup_cache(cpu, NativeFunc) maka
    # Inject dependensi Lexer ke CPU Globals (bukan cache modul)

    # 1. Morph Token (T)
    biar T_exports = {}
    copy_exports_dict(T, T_exports)
    setitem(cpu.globals, "T", T_exports)
    tulis("DEBUG: T injected into globals? " + teks(cpu.globals.punya("T")))

    # 3. Stdlib Core Imports
    setitem(cpu.globals, "int", int)
    setitem(cpu.globals, "float", float)
    setitem(cpu.globals, "gabung", gabung)
    # panjang, tambah sudah ada dari init Prosesor

    # 4. Stdlib Teks Imports
    fungsi _wrap_iris(obj, awal, akhir_pos) maka
        kembali iris(obj, awal, akhir_pos)
    akhir
    setitem(cpu.globals, "iris", NativeFunc("iris", _wrap_iris))
    tulis("DEBUG: iris injected into globals? " + teks(cpu.globals.punya("iris")))

    # 5. Warna
    biar Warna_exports = {}
    setitem(Warna_exports, "MERAH", Warna.MERAH)
    setitem(Warna_exports, "KUNING", Warna.KUNING)
    setitem(cpu.globals, "Warna", Warna_exports)
akhir

fungsi utama() maka
    tulis("--- Persiapan Native VM untuk Lexer ---")

    biar cpu = Proc.Prosesor()
    cpu.inisiasi()

    biar NativeFunc = cpu.globals["panjang"].__class__
    setitem(cpu.globals, "_getattr", NativeFunc("_getattr", _native_getattr))
    setitem(cpu.globals, "_setattr", NativeFunc("_setattr", _native_setattr))
    setitem(cpu.globals, "_getitem", NativeFunc("_getitem", getitem))
    setitem(cpu.globals, "_setitem", NativeFunc("_setitem", setitem))
    setitem(cpu.globals, "_host_contains", NativeFunc("_host_contains", contains))
    setitem(cpu.globals, "_call_host", NativeFunc("_call_host", _native_call_host))
    setitem(cpu.globals, "_buat_instance", NativeFunc("_buat_instance", _native_buat_instance))
    setitem(cpu.globals, "_is_callable", NativeFunc("_is_callable", _native_is_callable))

    setup_cache(cpu, NativeFunc)

    # DEBUG GLOBALS
    tulis("Globals Keys: " + teks(kunci(cpu.globals)))

    # --- Instantiate Lexer (Host Side) ---
    biar sumber_kode = "biar x = 10 + 20"
    biar err_handler = H.PengelolaKesalahan()
    biar lexer_host = LexerModul.Leksikal(sumber_kode, "test_native.fox", err_handler)

    biar method_buat_token = lexer_host.buat_token
    biar fungsi_morph = method_buat_token.method
    biar kode_buat_token_host = fungsi_morph.code

    biar kode_native = konversi_kode(kode_buat_token_host)

    # BUNGKUS kode_native sebagai Fungsi Native (Dictionary)
    # agar Prosesor menggunakan globals yang benar
    biar fungsi_native_dict = {
        "_tipe": "Fungsi",
        "nama": "buat_token",
        "code": kode_native,
        "globals": cpu.globals # Bind ke globals yang sudah kita inject
    }

    tulis("Fungsi Lexer Native siap.")

    # --- Jalankan di Native VM ---
    biar Op = Opc.Op
    biar instruksi_wrapper = []

    tambah(instruksi_wrapper, [Op["PUSH_CONST"], fungsi_native_dict]) # Callee (Native Func Dict)
    tambah(instruksi_wrapper, [Op["PUSH_CONST"], lexer_host])         # Arg 0: ini
    tambah(instruksi_wrapper, [Op["CALL"], 1])                        # Call 1 Arg

    # Hasil Token
    tambah(instruksi_wrapper, [Op["STORE_VAR"], "hasil_token"])

    # Print Hasil
    tambah(instruksi_wrapper, [Op["PUSH_CONST"], "Token Result: "])
    tambah(instruksi_wrapper, [Op["PRINT"], 1])

    tambah(instruksi_wrapper, [Op["LOAD_VAR"], "hasil_token"])
    tambah(instruksi_wrapper, [Op["LOAD_ATTR"], "tipe"])
    tambah(instruksi_wrapper, [Op["PRINT"], 1])

    tambah(instruksi_wrapper, [Op["LOAD_VAR"], "hasil_token"])
    tambah(instruksi_wrapper, [Op["LOAD_ATTR"], "nilai"])
    tambah(instruksi_wrapper, [Op["PRINT"], 1])

    tambah(instruksi_wrapper, [Op["RET"], nil])

    biar wrapper_kode = S.ObjekKode("wrapper_test", instruksi_wrapper, [], ["hasil_token", "Token Result: ", "tipe", "nilai"])

    tulis("--- Mengeksekusi Wrapper ---")
    cpu.jalan(wrapper_kode)
    tulis("--- Selesai Eksekusi ---")
akhir
