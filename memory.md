* After completing a major task, the user prefers a discussion phase to define the future vision and next steps before any new work plan is created.
* In the current development environment, `dune exec` is unreliable for running the OCaml compiler. The correct procedure is to first build with `dune build` and then run the executable directly via its full path, providing input and output files as arguments (e.g., `universal/_build/default/main.exe tests/test.fox output.json`).
* Obsolete test files should be moved to a `tests/archived_tests` directory instead of being deleted. A `README.md` file should be maintained in this directory explaining why the tests were archived.
* The MORPH language requires statements to be terminated by a semicolon or a newline.
* The OCaml compiler, located in the `universal/` directory, uses `dune`, `menhir`, and `ocamllex` to parse MORPH code and emit a JSON-formatted, Python-compatible AST.
* The MORPH interpreter is a tree-walking interpreter. Deep recursion in MORPH code consumes the Python call stack directly, which can lead to a Python `RecursionError`. This architectural constraint requires careful management of recursion, such as using a manual counter at the visitor level (`kunjungi_PanggilFungsi` method) rather than relying on `sys.setrecursionlimit`.
* The standardized communication protocol between the OCaml compiler and the Python interpreter is defined in `docs/AST_JSON_SPEC.md`, which is the single source of truth for the JSON AST structure.
* The MORPH language supports error handling with `coba maka ... akhir` (try), `tangkap (e) maka ... akhir` (catch), and `selalu maka ... akhir` (finally) blocks.
* To make Python `awaitable` objects (like coroutines) work correctly with MORPH's `tunggu` keyword via the FFI, the `PythonObject` wrapper class in `transisi/pembungkus.py` must implement the `__await__` dunder method. This method should delegate the await operation directly to the wrapped Python object (e.g., `return self.obj.__await__()`).
* In the MORPH language, variable declaration uses the `biar` keyword. Re-assignment of existing variables requires the `ubah` keyword (e.g., `ubah x = 10`).
* The MORPH interpreter uses a hierarchy of custom exceptions defined in `transisi/kesalahan.py` to provide specific runtime error details.
* MORPH does not support keyword/named arguments in function calls, including for constructors and FFI calls. All arguments must be passed positionally.
* The interpreter detects circular module imports and raises a `KesalahanRuntime` with an informative message showing the import chain.
* Expression-like built-in functions are implemented by wrapping native Python callables in a `FungsiBawaan` class and registering them in the interpreter's global environment. This avoids creating custom AST nodes for each function.
* The MORPH language supports classes using the syntax `kelas Nama warisi Induk maka ... akhir`. The constructor is a method named `inisiasi`, the keyword `ini` refers to the instance (like `this`/`self`), and `induk` refers to the superclass (like `super`).
* The FFI's `morph_to_python` conversion function in `transisi/ffi.py` can 'unwrap' a MORPH `PythonObject`. If it receives a `PythonObject` as input, it returns the raw Python object held inside, allowing wrapped objects to be passed to other FFI helper functions.
* The user prefers robust test file management. For temporary files, using Python's `tempfile` module within a pytest fixture is preferred over manual file creation and `os.remove`.
* The error formatter in `transisi/error_utils.py` is configured to include details from underlying Python exceptions when formatting `KesalahanFFI` runtime errors.
* The MORPH interpreter provides user-friendly error messages in Bahasa Indonesia. For Lexer and Parser errors, the message now includes the source code line and a pointer ('^') indicating the column of the error.
* The interactive REPL (Read-Eval-Print Loop) supports special commands: `keluar()` to exit the session and `reset()` to clear the current state (variables, functions).
* The MORPH language supports logical operators 'dan' (and) and 'atau' (or) with short-circuit evaluation.
* The working `dune` configuration for the OCaml executable involves a flat file structure in the `universal/` directory and a single `dune` file with top-level `(executable)`, `(menhir)`, and `(ocamllex)` stanzas. The `dune-project` file must include `(using menhir 2.1)`.
* In a MORPH `jika` (if) statement, the `lain` (else) clause does not use a `maka` keyword. It must be followed directly by a newline before its statement block.
* For backward compatibility, the MORPH parser (`transisi/crusher.py`) accepts both `kembali` and `kembalikan` as valid return keywords. The modern convention established in new code is `kembali`.
* The user is interested in the concept of self-sovereign identity systems, where users have full control over their credentials and data, with the explicit design choice of having no account recovery mechanisms.
* The full test suite has dependencies not listed in `requirements-dev.txt`, including `pytest`, `pytest-asyncio`, `psutil`, and `aiohttp`, which must be installed via `pip`.
* The parser in `transisi/crusher.py` now correctly converts literal tokens for `benar`, `salah`, and `nil` into `Konstanta` AST nodes containing the corresponding Python values (`True`, `False`, `None`).
* In the MORPH module system, symbols (variables, functions) are exported unless their name starts with an underscore (`_`), which is the convention for private symbols.
* New compiler and codegen-related logic will be located in the `transisi/compiler` directory.
* A MORPH `tipe` (discriminated union) declaration must be on a single line. The first variant is not preceded by a `|`, and the declaration is not terminated by an `akhir` keyword (e.g., `tipe Nama = Varian1 | Varian2`).
* A persistent Menhir compilation error ("This pattern should not be a constructor, the expected type is Ast.token") can be caused by a type name collision between Menhir's internal `token` type and a custom `Ast.token` type. Renaming the custom AST's token type (e.g., to `Ast.ast_token`) resolves the conflict.
* If a blocker is encountered during implementation, I should stop and ask for clarification rather than guessing a solution.
* The MORPH FFI is not currently designed to handle callbacks, where a MORPH function is passed as an argument to a Python function via FFI and then called from Python. Complex standard library functions like `filter` or `peta` will require native implementation in the interpreter.
* The MORPH parser distinguishes between variable re-assignment (which requires the `ubah` keyword) and property/item assignment (e.g., `ini.prop = val` or `daftar[i] = val`), which do not use `ubah`. The parser's `_penugasan` rule handles property and item assignments.
* The MORPH parser does not support type annotations in function parameters (e.g., `fungsi(nama: Tipe)`).
* The long-term architectural vision for MORPH is a dual-backend system: the existing Python interpreter and a new OCaml-based compiler. The MORPH AST serves as the universal intermediate representation. New language features are designed with OCaml as the primary compilation target.
* The MORPH module system supports two syntaxes: `ambil_semua "path" [sebagai alias]` and `ambil_sebagian simbol1, simbol2 dari "path"`.
* There are naming inconsistencies for tokens between the OCaml compiler (e.g., "BINTANG", "PERSEN", "LPAREN") and the Python interpreter's `TipeToken` enum (e.g., `TipeToken.KALI`, `TipeToken.MODULO`, `TipeToken.KURUNG_BUKA`). A manual mapping in `transisi/ocaml_loader.py` is required to resolve these differences during JSON deserialization.
* I must communicate with the user in Bahasa Indonesia.
* The MORPH parser in `transisi/crusher.py` now supports `asink fungsi` declarations directly within `kelas` blocks.
* The MORPH `tulis` (print) function has specific output formatting: it separates multiple arguments with a single space, string values are surrounded by double quotes, `None` is output as the literal string `nil`, and it does not add a trailing newline.
* The MORPH language uses a `selama <kondisi> maka ... akhir` block structure for while loops.
* Using `berhenti` or `lanjutkan` outside of a valid context should produce the specific satirical error message: "priiittttt.. kamu melewati garis yang sudah ditetapkan".
* The MORPH interpreter resolves module paths in the following order: 1) Relative to the importing file, 2) Directories in the `MORPH_PATH` environment variable, 3) A built-in standard library path. Absolute paths are resolved directly.
* Test fixtures should be consistent. Fixtures with similar purposes, like `capture_output` and `run_morph_program`, should be unified or delegate to one another to avoid regressions when the underlying code they test is refactored. `capture_output` was refactored to use `run_morph_program` internally.
* The Morph Netbase system is controlled via a declarative command file (`netbase.json`). User interactions are expressed as commands that reference data using a coordinate system (e.g., `1a` for Subjek 1, Predikat a).
* Error handling should be precise. Runtime exceptions should be raised with a valid Token object to provide line/column context. If a real token is unavailable, a dummy token should be created with the relevant location information.
* When refactoring causes pre-existing tests to fail, I am expected to fix those tests to align with the new implementation, even if pre-commit instructions allow for pre-existing failures.
* Development dependencies are specified in `requirements-dev.txt` and should be installed using `pip install -r requirements-dev.txt`.
* The core execution engine in `transisi/Morph.py` is split into two methods: `_jalankan_async(code, filename)` which contains the core asynchronous logic, and `_jalankan_sync(code, filename)` which acts as a synchronous wrapper using `asyncio.run()`. The REPL uses this synchronous wrapper to maintain state.
* The MORPH language supports a switch/case control structure using the syntax `pilih <ekspresi> ... ketika <nilai> maka ... lainnya maka ... akhir`.
* The MORPH language supports arithmetic operators for modulo (%) and exponentiation (^). The exponentiation operator is right-associative and has higher precedence than multiplication/division.
* The user has prioritized fixing core language limitations and 'trap bugs' (like the initial lack of method calls) over adding new standard library features in the short term.
* When I get stuck on a problem, especially one I've encountered before, the user may provide hints by referencing past successful solutions or `memory.md`. I should prioritize these hints.
* To instantiate a MORPH discriminated union variant, the variant name must be called directly as a function (e.g., `VARIAN()`). Variants are exported from their module and are not accessed as properties of the type name (e.g., not `TIPE.VARIAN()`).
* The test suite is run from the project root using `PYTHONPATH=. python3 -m pytest`.
* The MORPH language uses `berhenti` for `break` and `lanjutkan` for `continue`. `berhenti` is valid within `selama` (while) and `pilih` (switch) blocks. `lanjutkan` is only valid within `selama` blocks.
* The MORPH interpreter features a stack trace for runtime errors in nested function calls. The call stack is preserved by attaching it to the runtime exception object as it unwinds.
* The current strategic priority is the compiler bootstrapping project. The agreed-upon roadmap is: Phase 1 (Proof of Concept using a JSON AST bridge between the OCaml compiler and Python interpreter), followed by phases for creating a high-level Intermediate Representation (IR) and finally self-hosting.
* For complex FFI operations or logic that cannot be expressed directly in MORPH, the established pattern is to create an internal Python helper module (e.g., `_stdlib_internal.py`) containing wrapper functions, and then call these functions from MORPH code via `pinjam`.
* For example usernames, the user prefers `vzoel` and `fox` over generic names like `udin saprudin`.
* The MORPH language does not have a `properti` keyword for class attributes. Attributes must be defined and assigned to `ini` within the `inisiasi` constructor method.
* The MORPH parser requires that the `maka` keyword, used in control flow blocks like `fungsi`, `jika`, and `jodohkan`, must be followed by a newline.
* The MORPH language ecosystem distinguishes between code files (`.fox`) and standard JSON data files (`.json`).
* The Morph Netbase feature is built on a Semantic Data Architecture using a Subjek-Predikat-Objek (SPO) model for its internal database.
* The `morphupgrade` (transpiler) project is obsolete and has been superseded by the `transisi` (interpreter) project. Obsolete tests related to `morphupgrade` should be archived.
* The MORPH lexer (`lx.py`) supports single-line comments starting with `//`.
* The communication layer for Morph Netbase (the EPN) is implemented using a simple filesystem-based 'inbox' model. Messages are encrypted and placed in a directory corresponding to the recipient's username (e.g., `netbase/jaringan/inbox/fox/`).
* The MORPH module system caches modules based on their absolute path. The cache now uses a FIFO eviction policy and has a configurable size via the `MORPH_MODULE_CACHE_SIZE` environment variable.
* The user has a strong preference for maintaining a 100% passing test suite. All pre-existing test failures should be fixed rather than ignored.
* The user provides highly detailed, structured feedback in the form of "Score Cards" and "Test Coverage Analysis" after submissions. This feedback should be treated as the plan for the next iteration of work.
* The MORPH `jika/maka/lain` (if/then/else) construct is a block statement, not an inline expression (like a ternary operator). Each clause (`maka` and `lain`) must introduce a new block, typically on a new line.
* The `transisi` project is an interpreter for the MORPH programming language, following a classic architecture: Lexer (`lx.py`), Parser (`crusher.py`), AST definitions (`absolute_sntx_morph.py`), and Interpreter (`translator.py`).
* For bug fixes, the user prefers a Test-Driven Development (TDD) like workflow: 1. Write a new, failing test case that specifically reproduces the bug. 2. Implement the code fix to make the test pass. 3. Add more comprehensive tests to the affected area to improve robustness.
* The source code for the new self-hosting MORPH compiler will reside in a new top-level 'morph/' directory.
* The project has begun a long-term initiative to create a self-hosting compiler. This involves rewriting the Python interpreter from the 'transisi/' directory into the MORPH language itself.
* The Morph interpreter can be executed from the command line on a file using `python3 -m transisi.Morph <filename>`.
* Custom pytest markers (e.g., `@pytest.mark.stdlib`) must be registered in the `pytest.ini` file under the `[pytest]` section's `markers` list to prevent test collection errors.
* A detailed roadmap exists for building a MORPH Standard Library. Development begins with Milestone v2.0, which includes the "Prioritas Wajib" (Mandatory Priority) modules (`matematik`, `waktu`, `teks`, `daftar`). These modules will be located in the `transisi/stdlib/wajib/` directory.
* In MORPH classes, properties and methods are considered private if their names start with an underscore (`_`). The interpreter enforces this privacy at runtime by raising a `KesalahanNama` on access attempts from outside the class.
* The `selama` (while) loops have an iteration limit to prevent infinite execution. The limit is configurable via the `MORPH_LOOP_LIMIT` environment variable.
* The interpreter's main entry point in `transisi/Morph.py` now captures and prints the stdout stream from the executed MORPH program.
* The OCaml compiler is built by running `eval $(opam env) && cd universal && dune build` from the project root.
* The MORPH language has a module system with keywords: `ambil_semua` (import all), `ambil_sebagian` (import specific symbols), `sebagai` (as alias), and `dari` (from).
* The main entry point (`transisi/Morph.py`) is integrated with `asyncio`. It uses an `async def` method for core logic and a synchronous wrapper with `asyncio.run()` to start the execution, enabling top-level asynchronous code.
* The user envisions a future package management system using `.fall` files for dependencies and a `star summon` command for installation.
* For security-sensitive operations like hashing and encryption, the preferred pattern is to use MORPH's `pinjam` FFI to bridge to established, secure Python libraries such as `hashlib` and `cryptography`, rather than implementing crypto algorithms in MORPH.
* The interpreter's global environment and built-in function registration logic is located in `transisi/translator.py`. The `Penerjemah` class's `__init__` method is the entry point for defining global symbols.
* A key requirement for the OCaml compiler is that AST nodes must contain accurate source code location information (line and column). This is achieved in `parser.mly` by using menhir's `$startpos(symbol)` and `$endpos(symbol)` constructs within grammar rule actions to create token records.
* The OCaml compiler executable, as defined in `universal/dune`, is named `main`. It is located at `universal/_build/default/main.exe` after a successful build.
* When the user provides code review feedback, it must be treated as the definitive source of truth and implemented, even if it contradicts a previously completed solution.
* When the user provides a detailed analysis from their "analyst team," it should be treated as the definitive solution to a problem, overriding any previous implementation attempts or debugging paths.
* As part of the self-hosting compiler initiative, the user wants to expand the MORPH language by adding a standard library, including modules for date/time, math, random, and package management utilities.
* The OCaml compiler architecture separates lexer tokens from AST tokens. The lexer (`.mll` file) should open the `Parser` module and produce the simple `Parser.token` types generated by Menhir. The parser actions (`.mly` file) are then responsible for constructing the richer, metadata-filled `Ast.ast_token` records for the final AST.
* The user prefers a collaborative, phased workflow: 1. Deep analysis to find the root cause. 2. A discussion of the findings to agree on the next steps. 3. Creation and execution of a plan to implement the agreed-upon solution.
* The MORPH interpreter supports method call syntax (`objek.metode(argumen)`). The parser handles this by creating a `PanggilFungsi` AST node whose callee is an `AmbilProperti` node, effectively reusing the existing function call and property access logic without needing a dedicated `PanggilMetode` AST node.
* After a major set of fixes, the user prefers to create a new, consolidated test suite (e.g., `test_high_priority_fixes.py`) to formally validate all fixes in one place.
* The interpreter's core logic should collect and return a list of formatted errors, while the user-facing entry-point methods (e.g., `jalankan_file`, `jalankan_prompt`) are responsible for printing those errors to the user.
* The FFI architecture uses an `FFIBridge` class in `transisi/ffi.py`. The `PythonObject` wrapper class was moved to its own file, `transisi/pembungkus.py`, to avoid circular import issues. The bridge maintains a cache of loaded modules.
* MORPH supports pattern matching using `jodohkan ... dengan`. Supported patterns include literals, a wildcard (`_`), and destructuring of custom discriminated union variants (e.g., `| Sukses(data) maka ...`).
* A new feature, "Morph Netbase", has been created. It is a self-sovereign data and communication platform built in MORPH, with its core modules located in the `netbase/` directory.
* Implementation of standard library functions that require callbacks from MORPH to Python (e.g., `filter`, `peta`, `reduksi`) has been deferred to a future task.
* The `pinjam` keyword is implemented, providing a Foreign Function Interface (FFI) to Python modules. The syntax is `pinjam "module.name" sebagai alias`.
* When the user provides a numbered list of tasks or patches, they must be executed sequentially in the specified order.
* Morph Netbase includes a storage management feature where data objects can be marked as `+` (active) for full synchronization or `-` (archived) to be kept only in local storage, conserving server/VPS resources.
* The lexer (`lx.py`) reports errors as a list of dictionaries (`[{'pesan': ..., 'baris': ..., 'kolom': ..., 'file': ...}]`).
* When the user provides example code, they distinguish between 'final implementation' code (which should be used verbatim) and 'template/guide' code (which should be adapted to the existing architecture).
* A key architectural pattern for the project is a "State Synchronization Engine". This involves a declarative, user-facing file (e.g., `netbase.json`) that defines the desired state of the system. An automated process then reconciles this desired state with an internal, structured database, applying changes (adds, updates, deletes) to match the declaration. This approach is inspired by Infrastructure-as-Code principles.
* MORPH has a built-in function `baca_json(path)` for reading and parsing JSON data files.
* The MORPH Standard Library is being built inside the `transisi/stdlib/` directory. It is structured into subdirectories based on priority (e.g., `wajib/`, `tinggi/`) as defined in the project's roadmap.
* The `Tunggu` AST node stores its keyword token in the `.kata_kunci` attribute, not `.token`, which is critical for correct error reporting from the interpreter.
* The `pytest.ini` file is used for test configuration. The `norecursedirs` option should be used to exclude directories, such as `tests/archived_tests`, from test discovery.
* The MORPH language supports 'tetap' for constant variable declarations, which are enforced at runtime to be immutable by checking for reassignment.
* When debugging, errors like `AttributeError: 'coroutine' object has no attribute '...'` or `RuntimeWarning: coroutine ... was never awaited` are strong indicators that an `async def` method was called without a preceding `await`. This is a common issue after large asynchronous refactoring.
* During the development of the self-hosting compiler, the new MORPH code in the 'morph/' directory will be executed and tested using the existing Python interpreter from the 'transisi/' directory.
* New applications or features should follow a modular design, separating concerns into distinct files or libraries (e.g., a security/crypto layer, a business logic/profile management layer, and a presentation/UI layer).
* The OCaml environment requires `opam`. The setup sequence is: `sudo apt-get update && sudo apt-get install -y opam`, `opam init --disable-sandboxing --auto-setup`, `eval $(opam env)`, and `opam install -y dune menhir yojson`.
* When debugging FFI-related issues, surface-level parser syntax errors (e.g., an error on an assignment keyword like `ubah`) can be misleading. The root cause is often a deeper limitation of the FFI, such as its inability to handle specific syntax (like method calls) or data types on the right-hand side of the expression.
* MORPH supports asynchronous programming with `asink` and `tunggu` keywords. The core tree-walking interpreter in `translator.py` has been refactored to be fully asynchronous, with visitor and execution methods defined as `async def`.
* The Morph Netbase application has evolved into a persistent background service (`daemon.fox`) that runs in a continuous loop, using a time-based 'floodwait' timer for synchronization. The `main.fox` file is now a utility script for profile creation.
* A command-line runner script at the root of the project, named `morph_cli`, is a relic from a previous engine and is distinct from the current `transisi` interpreter and the new `morph/` compiler project.
* The Python interpreter's entry point (`transisi/Morph.py`) supports a `--use-ocaml-loader` command-line flag. When present, it bypasses the Python parser and instead loads and executes a JSON AST file provided as an argument.
* To add a new language feature to MORPH, the workflow involves updating token definitions (`morph_t.py`), the lexer (`lx.py`), the parser (`crusher.py`) to build an AST node, and the interpreter (`translator.py`) to execute that AST node.
* The repository contains multiple projects, including `fox_engine` (an async task framework) and `transisi` (interpreter). The entire codebase, including comments, variables, and documentation, is written in Bahasa Indonesia.
* Before making any changes, I must enter a 'deep planning mode'. This involves asking clarifying questions over multiple turns using `request_user_input` to achieve absolute certainty, reflecting on the user's answers to formulate new questions, and testing every assumption. The goal is to understand the user's expectations, not to get a plan approved. I will only create a plan with `set_plan` after all doubt is eliminated.
* The user prefers robust test file management. For temporary files, using Python's `tempfile` module within a pytest fixture is preferred over manual file creation and `os.remove`.
* The MORPH `tulis` (print) function has specific output formatting: it separates multiple arguments with a single space, string values are surrounded by double quotes, `None` is output as the literal string `nil`, and it does not add a trailing newline.
* The MORPH language supports a switch/case control structure using the syntax `pilih <ekspresi> ... ketika <nilai> maka ... lainnya maka ... akhir`.
* The MORPH language supports logical operators 'dan' (and) and 'atau' (or) with short-circuit evaluation.
* The MORPH language supports arithmetic operators for modulo (%) and exponentiation (^). The exponentiation operator is right-associative and has higher precedence than multiplication/division.
* The user has prioritized fixing core language limitations and 'trap bugs' (like the initial lack of method calls) over adding new standard library features in the short term.
* When I get stuck on a problem, especially one I've encountered before, the user may provide hints by referencing past successful solutions or `memory.md`. I should prioritize these hints.
* To instantiate a MORPH discriminated union variant, the variant name must be called directly as a function (e.g., `VARIAN()`). Variants are exported from their module and are not accessed as properties of the type name (e.g., not `TIPE.VARIAN()`).
* The test suite is run from the project root using `PYTHONPATH=. python3 -m pytest`.
* The MORPH language uses `berhenti` for `break` and `lanjutkan` for `continue`. `berhenti` is valid within `selama` (while) and `pilih` (switch) blocks. `lanjutkan` is only valid within `selama` blocks.
* The MORPH interpreter features a stack trace for runtime errors in nested function calls. The call stack is preserved by attaching it to the runtime exception object as it unwinds.
* The current strategic priority is the compiler bootstrapping project. The agreed-upon roadmap is: Phase 1 (Proof of Concept using a JSON AST bridge between the OCaml compiler and Python interpreter), followed by phases for creating a high-level Intermediate Representation (IR) and finally self-hosting.
* For complex FFI operations or logic that cannot be expressed directly in MORPH, the established pattern is to create an internal Python helper module (e.g., `_stdlib_internal.py`) containing wrapper functions, and then call these functions from MORPH code via `pinjam`.
* For example usernames, the user prefers `vzoel` and `fox` over generic names like `udin saprudin`.
* The MORPH language does not have a `properti` keyword for class attributes. Attributes must be defined and assigned to `ini` within the `inisiasi` constructor method.
* The MORPH parser requires that the `maka` keyword, used in control flow blocks like `fungsi`, `jika`, and `jodohkan`, must be followed by a newline.
* The MORPH language ecosystem distinguishes between code files (`.fox`) and standard JSON data files (`.json`).
* The Morph Netbase feature is built on a Semantic Data Architecture using a Subjek-Predikat-Objek (SPO) model for its internal database.
* The `morphupgrade` (transpiler) project is obsolete and has been superseded by the `transisi` (interpreter) project. Obsolete tests related to `morphupgrade` should be archived.
* The MORPH lexer (`lx.py`) supports single-line comments starting with `//`.
* The communication layer for Morph Netbase (the EPN) is implemented using a simple filesystem-based 'inbox' model. Messages are encrypted and placed in a directory corresponding to the recipient's username (e.g., `netbase/jaringan/inbox/fox/`).
* The MORPH module system caches modules based on their absolute path. The cache now uses a FIFO eviction policy and has a configurable size via the `MORPH_MODULE_CACHE_SIZE` environment variable.
* The user has a strong preference for maintaining a 100% passing test suite. All pre-existing test failures should be fixed rather than ignored.
* The user provides highly detailed, structured feedback in the form of "Score Cards" and "Test Coverage Analysis" after submissions. This feedback should be treated as the plan for the next iteration of work.
* The MORPH `jika/maka/lain` (if/then/else) construct is a block statement, not an inline expression (like a ternary operator). Each clause (`maka` and `lain`) must introduce a new block, typically on a new line.
* The `transisi` project is an interpreter for the MORPH programming language, following a classic architecture: Lexer (`lx.py`), Parser (`crusher.py`), AST definitions (`absolute_sntx_morph.py`), and Interpreter (`translator.py`).
* For bug fixes, the user prefers a Test-Driven Development (TDD) like workflow: 1. Write a new, failing test case that specifically reproduces the bug. 2. Implement the code fix to make the test pass. 3. Add more comprehensive tests to the affected area to improve robustness.
* The source code for the new self-hosting MORPH compiler will reside in a new top-level 'morph/' directory.
* The project has begun a long-term initiative to create a self-hosting compiler. This involves rewriting the Python interpreter from the 'transisi/' directory into the MORPH language itself.
* The Morph interpreter can be executed from the command line on a file using `python3 -m transisi.Morph <filename>`.
* Custom pytest markers (e.g., `@pytest.mark.stdlib`) must be registered in the `pytest.ini` file under the `[pytest]` section's `markers` list to prevent test collection errors.
* A detailed roadmap exists for building a MORPH Standard Library. Development begins with Milestone v2.0, which includes the "Prioritas Wajib" (Mandatory Priority) modules (`matematik`, `waktu`, `teks`, `daftar`). These modules will be located in the `transisi/stdlib/wajib/` directory.
* In MORPH classes, properties and methods are considered private if their names start with an underscore (`_`). The interpreter enforces this privacy at runtime by raising a `KesalahanNama` on access attempts from outside the class.
* The `selama` (while) loops have an iteration limit to prevent infinite execution. The limit is configurable via the `MORPH_LOOP_LIMIT` environment variable.
* The interpreter's main entry point in `transisi/Morph.py` now captures and prints the stdout stream from the executed MORPH program.
* The OCaml compiler is built by running `eval $(opam env) && cd universal && dune build` from the project root.
* The MORPH language has a module system with keywords: `ambil_semua` (import all), `ambil_sebagian` (import specific symbols), `sebagai` (as alias), and `dari` (from).
* The main entry point (`transisi/Morph.py`) is integrated with `asyncio`. It uses an `async def` method for core logic and a synchronous wrapper with `asyncio.run()` to start the execution, enabling top-level asynchronous code.
* The user envisions a future package management system using `.fall` files for dependencies and a `star summon` command for installation.
* For security-sensitive operations like hashing and encryption, the preferred pattern is to use MORPH's `pinjam` FFI to bridge to established, secure Python libraries such as `hashlib` and `cryptography`, rather than implementing crypto algorithms in MORPH.
* The interpreter's global environment and built-in function registration logic is located in `transisi/translator.py`. The `Penerjemah` class's `__init__` method is the entry point for defining global symbols.
* A key requirement for the OCaml compiler is that AST nodes must contain accurate source code location information (line and column). This is achieved in `parser.mly` by using menhir's `$startpos(symbol)` and `$endpos(symbol)` constructs within grammar rule actions to create token records.
* The OCaml compiler executable, as defined in `universal/dune`, is named `main`. It is located at `universal/_build/default/main.exe` after a successful build.
* When the user provides code review feedback, it must be treated as the definitive source of truth and implemented, even if it contradicts a previously completed solution.
* When the user provides a detailed analysis from their "analyst team," it should be treated as the definitive solution to a problem, overriding any previous implementation attempts or debugging paths.
* As part of the self-hosting compiler initiative, the user wants to expand the MORPH language by adding a standard library, including modules for date/time, math, random, and package management utilities.
* The OCaml compiler architecture separates lexer tokens from AST tokens. The lexer (`.mll` file) should open the `Parser` module and produce the simple `Parser.token` types generated by Menhir. The parser actions (`.mly` file) are then responsible for constructing the richer, metadata-filled `Ast.ast_token` records for the final AST.
* The user prefers a collaborative, phased workflow: 1. Deep analysis to find the root cause. 2. A discussion of the findings to agree on the next steps. 3. Creation and execution of a plan to implement the agreed-upon solution.
* The MORPH interpreter supports method call syntax (`objek.metode(argumen)`). The parser handles this by creating a `PanggilFungsi` AST node whose callee is an `AmbilProperti` node, effectively reusing the existing function call and property access logic without needing a dedicated `PanggilMetode` AST node.
* After a major set of fixes, the user prefers to create a new, consolidated test suite (e.g., `test_high_priority_fixes.py`) to formally validate all fixes in one place.
* The interpreter's core logic should collect and return a list of formatted errors, while the user-facing entry-point methods (e.g., `jalankan_file`, `jalankan_prompt`) are responsible for printing those errors to the user.
* The FFI architecture uses an `FFIBridge` class in `transisi/ffi.py`. The `PythonObject` wrapper class was moved to its own file, `transisi/pembungkus.py`, to avoid circular import issues. The bridge maintains a cache of loaded modules.
* MORPH supports pattern matching using `jodohkan ... dengan`. Supported patterns include literals, a wildcard (`_`), and destructuring of custom discriminated union variants (e.g., `| Sukses(data) maka ...`).
* A new feature, "Morph Netbase", has been created. It is a self-sovereign data and communication platform built in MORPH, with its core modules located in the `netbase/` directory.
* Implementation of standard library functions that require callbacks from MORPH to Python (e.g., `filter`, `peta`, `reduksi`) has been deferred to a future task.
* The `pinjam` keyword is implemented, providing a Foreign Function Interface (FFI) to Python modules. The syntax is `pinjam "module.name" sebagai alias`.
* When the user provides a numbered list of tasks or patches, they must be executed sequentially in the specified order.
* Morph Netbase includes a storage management feature where data objects can be marked as `+` (active) for full synchronization or `-` (archived) to be kept only in local storage, conserving server/VPS resources.
* The lexer (`lx.py`) reports errors as a list of dictionaries (`[{'pesan': ..., 'baris': ..., 'kolom': ..., 'file': ...}]`).
* When the user provides example code, they distinguish between 'final implementation' code (which should be used verbatim) and 'template/guide' code (which should be adapted to the existing architecture).
* A key architectural pattern for the project is a "State Synchronization Engine". This involves a declarative, user-facing file (e.g., `netbase.json`) that defines the desired state of the system. An automated process then reconciles this desired state with an internal, structured database, applying changes (adds, updates, deletes) to match the declaration. This approach is inspired by Infrastructure-as-Code principles.
* MORPH has a built-in function `baca_json(path)` for reading and parsing JSON data files.
* The MORPH Standard Library is being built inside the `transisi/stdlib/` directory. It is structured into subdirectories based on priority (e.g., `wajib/`, `tinggi/`) as defined in the project's roadmap.
* The `Tunggu` AST node stores its keyword token in the `.kata_kunci` attribute, not `.token`, which is critical for correct error reporting from the interpreter.
* The `pytest.ini` file is used for test configuration. The `norecursedirs` option should be used to exclude directories, such as `tests/archived_tests`, from test discovery.
* The MORPH language supports 'tetap' for constant variable declarations, which are enforced at runtime to be immutable by checking for reassignment.
* When debugging, errors like `AttributeError: 'coroutine' object has no attribute '...'` or `RuntimeWarning: coroutine ... was never awaited` are strong indicators that an `async def` method was called without a preceding `await`. This is a common issue after large asynchronous refactoring.
* During the development of the self-hosting compiler, the new MORPH code in the 'morph/' directory will be executed and tested using the existing Python interpreter from the 'transisi/' directory.
* New applications or features should follow a modular design, separating concerns into distinct files or libraries (e.g., a security/crypto layer, a business logic/profile management layer, and a presentation/UI layer).
* The OCaml environment requires `opam`. The setup sequence is: `sudo apt-get update && sudo apt-get install -y opam`, `opam init --disable-sandboxing --auto-setup`, `eval $(opam env)`, and `opam install -y dune menhir yojson`.
* When debugging FFI-related issues, surface-level parser syntax errors (e.g., an error on an assignment keyword like `ubah`) can be misleading. The root cause is often a deeper limitation of the FFI, such as its inability to handle specific syntax (like method calls) or data types on the right-hand side of the expression.
* MORPH supports asynchronous programming with `asink` and `tunggu` keywords. The core tree-walking interpreter in `translator.py` has been refactored to be fully asynchronous, with visitor and execution methods defined as `async def`.
* The Morph Netbase application has evolved into a persistent background service (`daemon.fox`) that runs in a continuous loop, using a time-based 'floodwait' timer for synchronization. The `main.fox` file is now a utility script for profile creation.
* A command-line runner script at the root of the project, named `morph_cli`, is a relic from a previous engine and is distinct from the current `transisi` interpreter and the new `morph/` compiler project.
* The Python interpreter's entry point (`transisi/Morph.py`) supports a `--use-ocaml-loader` command-line flag. When present, it bypasses the Python parser and instead loads and executes a JSON AST file provided as an argument.
* To add a new language feature to MORPH, the workflow involves updating token definitions (`morph_t.py`), the lexer (`lx.py`), the parser (`crusher.py`) to build an AST node, and the interpreter (`translator.py`) to execute that AST node.
* The repository contains multiple projects, including `fox_engine` (an async task framework) and `transisi` (interpreter). The entire codebase, including comments, variables, and documentation, is written in Bahasa Indonesia.
* Before making any changes, I must enter a 'deep planning mode'. This involves asking clarifying questions over multiple turns using `request_user_input` to achieve absolute certainty, reflecting on the user's answers to formulate new questions, and testing every assumption. The goal is to understand the user's expectations, not to get a plan approved. I will only create a plan with `set_plan` after all doubt is eliminated.
