* After completing a major task, the user prefers a discussion phase to define the future vision and next steps before any new work plan is created.
* A full build of the OCaml compiler can be triggered with `dune build` from within the `universal/` directory. The compiled executable must be run directly via its path (`./_build/default/main.exe`) and expects positional arguments for input and output files (`<input_file> <output_file>`), as `dune exec` can be unreliable and the executable does not support a `-o` flag.
* Do not delete test files, even if they seem obsolete or are failing due to major refactoring. They must be updated to reflect the new architecture to preserve unit test coverage. Deleting tests is a mistake that reduces quality assurance.
* The MORPH language's `jodohkan` (match) statement uses the syntax `jodohkan <ekspresi> dengan ... akhir`.
* The MORPH language grammar, particularly in the OCaml parser, uses the `NEWLINE` token as the primary statement separator.
* The project's logging system should be centralized, configurable via environment variables (`MORPH_LOG_LEVEL`, `MORPH_LOG_FILE`), and support standard Python logging levels (DEBUG, INFO, WARNING, ERROR).
* The MORPH language supports lists `[]`, dictionaries `{}`, and element/item access `[]`.
* The OCaml compiler, located in the `universal/` directory, uses `dune`, `menhir`, and `ocamllex` to parse MORPH code and emit a JSON-formatted, Python-compatible AST.
* The MORPH interpreter is a tree-walking interpreter. Deep recursion in MORPH code consumes the Python call stack directly, which can lead to a Python `RecursionError`. This architectural constraint requires careful management of recursion, such as using a manual counter at the visitor level (`kunjungi_PanggilFungsi` method) rather than relying on `sys.setrecursionlimit`.
* The JSON AST generated by the OCaml compiler includes a `lokasi` object for each node, which has a flat structure with keys: `start_line`, `start_col`, `end_line`, and `end_col`.
* The user prefers a hybrid, iterative development approach. This involves implementing a specific category of features and then immediately adding and running a 'smoke test' for that category before moving to the next iteration.
* The MORPH language supports error handling with `coba maka ... akhir` (try), `tangkap (e) maka ... akhir` (catch), and `selalu maka ... akhir` (finally) blocks.
* To resolve an AST structural discrepancy for `pilih` statements, the Python parser (`crusher.py`) was modified to wrap the `ketika` clause value in a list. This makes its output consistent with the OCaml loader, and the interpreter's `kunjungi_Pilih` method now expects the value to always be a list of expressions.
* To make Python `awaitable` objects (like coroutines) work correctly with MORPH's `tunggu` keyword via the FFI, the `PythonObject` wrapper class in `transisi/pembungkus.py` must implement the `__await__` dunder method. This method should delegate the await operation directly to the wrapped Python object (e.g., `return self.obj.__await__()`).
* Functions and types defined in an OCaml module (`.ml` file) are not accessible to other modules unless they are explicitly exposed in the corresponding interface file (`.mli`). A build error like `Unbound value Module.function` is a strong indicator that the function is missing from `Module.mli`.
* When a significant environmental blocker occurs (e.g., the OCaml compiler failing to run), the user may provide a pragmatic workaround, such as manually supplying the expected output file (e.g., a JSON AST), to unblock progress on dependent tasks.
* In the MORPH language, variable declaration uses the `biar` keyword. Re-assignment of existing variables requires the `ubah` keyword (e.g., `ubah x = 10`).
* The MORPH interpreter uses a hierarchy of custom exceptions defined in `transisi/kesalahan.py` to provide specific runtime error details.
* MORPH does not support keyword/named arguments in function calls, including for constructors and FFI calls. All arguments must be passed positionally.
* The interpreter detects circular module imports and raises a `KesalahanRuntime` with an informative message showing the import chain.
* Expression-like built-in functions are implemented by wrapping native Python callables in a `FungsiBawaan` class and registering them in the interpreter's global environment. This avoids creating custom AST nodes for each function.
* The MORPH language supports classes using the syntax `kelas Nama warisi Induk maka ... akhir`. The constructor is a method named `inisiasi`, the keyword `ini` refers to the instance (like `this`/`self`), and `induk` refers to the superclass (like `super`).
* The FFI's `morph_to_python` conversion function in `transisi/ffi.py` can 'unwrap' a MORPH `PythonObject`. If it receives a `PythonObject` as input, it returns the raw Python object held inside, allowing wrapped objects to be passed to other FFI helper functions.
* There is a persistent environmental issue where certain test files (e.g., `tests/sprint1_fixes.py`) appear in `ls` listings but cannot be accessed by tools like `read_file` or `replace_with_git_merge_diff`, preventing the fixing of tests within those files.
* The user prefers robust test file management. For temporary files, using Python's `tempfile` module within a pytest fixture is preferred over manual file creation and `os.remove`.
* Commits should be clean and not include temporary test files (e.g., `.morph` files used for a specific test run), build artifacts (e.g., compiled `.json` ASTs), or other accidental files.
* The error formatter in `transisi/error_utils.py` is configured to include details from underlying Python exceptions when formatting `KesalahanFFI` runtime errors.
* The interactive REPL (Read-Eval-Print Loop) supports special commands: `keluar()` to exit the session and `reset()` to clear the current state (variables, functions).
* The MORPH language supports logical operators 'dan' (and) and 'atau' (or) with short-circuit evaluation.
* The working `dune` configuration for the OCaml executable involves a flat file structure in the `universal/` directory and a single `dune` file with top-level `(executable)`, `(menhir)`, and `(ocamllex)` stanzas. The `dune-project` file must include `(using menhir 2.1)`.
* In a MORPH `jika` (if) statement, the `lain` (else) clause does not use a `maka` keyword. It must be followed directly by a newline before its statement block.
* For backward compatibility, the MORPH parser (`transisi/crusher.py`) accepts both `kembali` and `kembalikan` as valid return keywords. The modern convention established in new code is `kembali`.
* The user is interested in the concept of self-sovereign identity systems, where users have full control over their credentials and data, with the explicit design choice of having no account recovery mechanisms.
* The error formatter (`error_utils.py`) uses a priority system for determining error locations: 1. It prefers the location from the `error.token` if available, as it is the most specific. 2. It falls back to using the location from the AST `node.lokasi` dictionary. 3. As a final fallback, it uses the token even if its location data is less reliable.
* The parser in `transisi/crusher.py` now correctly converts literal tokens for `benar`, `salah`, and `nil` into `Konstanta` AST nodes containing the corresponding Python values (`True`, `False`, `None`).
* In the MORPH module system, symbols (variables, functions) are exported unless their name starts with an underscore (`_`), which is the convention for private symbols.
* New compiler and codegen-related logic will be located in the `transisi/compiler` directory.
* A MORPH `tipe` (discriminated union) declaration must be on a single line. The first variant is not preceded by a `|`, and the declaration is not terminated by an `akhir` keyword (e.g., `tipe Nama = Varian1 | Varian2`).
* The MORPH FFI does not support a 'splat' operator (e.g., `*args`). To pass a variable number of arguments from MORPH to a Python helper function, the MORPH function must pass a list, and the Python helper must be adapted to accept a list and unpack it internally (e.g., `def helper(parts): Path(*parts)`).
* If a blocker is encountered during implementation, I should stop and ask for clarification rather than guessing a solution.
* The OCaml parser (`universal/parser.mly`) has a complex and persistent bug related to `reduce/reduce` conflicts in the `jodohkan` statement rules. This makes it difficult to parse different pattern types (literals, variables, wildcards, variants) without ambiguity, blocking the feature's implementation.
* The interpreter in `translator.py` has been refactored for robust error propagation. Lower-level execution methods (like `_eksekusi`) are designed to let runtime exceptions bubble up. A top-level wrapper, `_eksekusi_dan_tangkap_error`, is responsible for catching these exceptions and formatting them for the user. This ensures that errors from nested function calls are correctly propagated and handled.
* The MORPH FFI is not currently designed to handle callbacks, where a MORPH function is passed as an argument to a Python function via FFI and then called from Python. Complex standard library functions like `filter` or `peta` will require native implementation in the interpreter.
* The MORPH parser distinguishes between variable re-assignment (which requires the `ubah` keyword) and property/item assignment (e.g., `ini.prop = val` or `daftar[i] = val`), which do not use `ubah`. The parser's `_penugasan` rule handles property and item assignments.
* The MORPH parser does not support type annotations in function parameters (e.g., `fungsi(nama: Tipe)`).
* The long-term architectural vision for MORPH is a dual-backend system: the existing Python interpreter and a new OCaml-based compiler. The MORPH AST serves as the universal intermediate representation. New language features are designed with OCaml as the primary compilation target.
* The MORPH module system supports two syntaxes: `ambil_semua "path" [sebagai alias]` and `ambil_sebagian simbol1, simbol2 dari "path"`.
* The Python parser (`crusher.py`) for the `jodohkan` statement uses capitalization to distinguish between pattern types derived from a `NAMA` token: names starting with an uppercase letter are parsed as `PolaVarian`, while names starting with a lowercase letter are parsed as `PolaIkatanVariabel`.
* I must communicate with the user in Bahasa Indonesia.
* The MORPH parser in `transisi/crusher.py` now supports `asink fungsi` declarations directly within `kelas` blocks.
* The MORPH language uses a `selama <kondisi> maka ... akhir` block structure for while loops.
* Due to the persistent OCaml parser bug, the user has approved a pragmatic "Python First" hybrid strategy for implementing new language features. The feature is to be fully implemented and tested in the Python parser (`crusher.py`) and interpreter (`translator.py`) first, while the OCaml implementation is deferred to a future task.
* The user wants to proceed with the project in a phased manner, focusing on one phase at a time. New test files required by a phase should be created from scratch.
* Using `berhenti` or `lanjutkan` outside of a valid context should produce the specific satirical error message: "priiittttt.. kamu melewati garis yang sudah ditetapkan".
* To display log messages during pytest execution, the `--log-cli-level=<LEVEL>` flag must be used, as pytest suppresses stderr output by default.
* To enable function declarations to be used as expressions (e.g., in variable assignments), the `kunjungi_FungsiDeklarasi` and `kunjungi_FungsiAsinkDeklarasi` methods in `transisi/translator.py` must return the `Fungsi` or `FungsiAsink` object they create.
* The MORPH interpreter resolves module paths in the following order: 1) Relative to the importing file, 2) Directories in the `MORPH_PATH` environment variable, 3) A built-in standard library path. Absolute paths are resolved directly.
* The `transisi.Morph.jalankan_dari_ocaml_ast` method is synchronous. It internally calls `_jalankan_sync`, which handles the `asyncio.run()` loop. Python tests that call this method must be synchronous and not use `await` or be marked with `@pytest.mark.asyncio`.
* Test fixtures should be consistent. Fixtures with similar purposes, like `capture_output` and `run_morph_program`, should be unified or delegate to one another to avoid regressions when the underlying code they test is refactored. `capture_output` was refactored to use `run_morph_program` internally.
* The Morph Netbase system is controlled via a declarative command file (`netbase.json`). User interactions are expressed as commands that reference data using a coordinate system (e.g., `1a` for Subjek 1, Predikat a).
* When refactoring causes pre-existing tests to fail, I am expected to fix those tests to align with the new implementation, even if pre-commit instructions allow for pre-existing failures.
* Development dependencies are specified in `requirements-dev.txt` and should be installed using `pip install -r requirements-dev.txt`.
* The core execution engine in `transisi/Morph.py` uses an `async def _jalankan_async(...)` method for its main logic. It provides a synchronous wrapper, `_jalankan_sync(...)`, which calls `asyncio.run()` on the async method. Public-facing methods like `jalankan_file` and `jalankan_dari_ocaml_ast` are synchronous and use the `_jalankan_sync` wrapper.
* For complex features, the user accepts temporary, simplified implementations (e.g., treating a complex pattern as a simple expression) as long as the simplification is clearly documented with `TODO` comments and a plan exists for a future, more robust implementation.
* The MORPH language supports arithmetic operators for modulo (%) and exponentiation (^). The exponentiation operator is right-associative and has higher precedence than multiplication/division.
* The user has prioritized fixing core language limitations and 'trap bugs' (like the initial lack of method calls) over adding new standard library features in the short term.
* When I get stuck on a problem, especially one I've encountered before, the user may provide hints by referencing past successful solutions or `memory.md`. I should prioritize these hints.
* To instantiate a MORPH discriminated union variant, the variant name must be called directly as a function (e.g., `VARIAN()`). Variants are exported from their module and are not accessed as properties of the type name (e.g., not `TIPE.VARIAN()`).
* The OCaml compiler is built by running `cd universal && dune build`.
* The OCaml environment requires `opam`. The setup sequence is: `sudo apt-get update && sudo apt-get install -y opam m4 pkg-config`, `opam init -y --disable-sandboxing`, `eval $(opam env)`, and `opam install dune menhir yojson -y`.
* MORPH's pattern matching (`jodohkan`) feature is being expanded to support `PolaIkatanVariabel` (variable binding, e.g., `| x maka ...`) and `PolaDaftar` (list destructuring, e.g., `| [a, b, _] maka ...`), in addition to literals, variants, and wildcards.
* The MORPH language uses `berhenti` for `break` and `lanjutkan` for `continue`. `berhenti` is valid within `selama` (while) and `pilih` (switch) blocks. `lanjutkan` is only valid within `selama` blocks.
* The MORPH interpreter features a stack trace for runtime errors in nested function calls. The call stack is preserved by attaching it to the runtime exception object as it unwinds.
* For complex FFI operations or logic that cannot be expressed directly in MORPH, the established pattern is to create an internal Python helper module (e.g., `_stdlib_internal.py`) containing wrapper functions, and then call these functions from MORPH code via `pinjam`.
* The OCaml environment (opam, dune) is unreliable in the tool's ephemeral shell session, often failing with 'command not found' errors even after a successful installation. This may require pragmatic workarounds, such as using pre-compiled artifacts provided by the user.
* For example usernames, the user prefers `vzoel` and `fox` over generic names like `udin saprudin`.
* The MORPH language does not have a `properti` keyword for class attributes. Attributes must be defined and assigned to `ini` within the `inisiasi` constructor method.
* The MORPH parser (`universal/parser.mly`) requires one or more `NEWLINE` tokens after the `maka` keyword in control flow blocks like `fungsi`, `jika`, and `selama`. The Python parser (`crusher.py`) follows the same convention.
* The MORPH language ecosystem distinguishes between code files (`.fox`) and standard JSON data files (`.json`).
* The `Tunggu` AST node stores its keyword token in the `.kata_kunci` attribute, not `.token`, which is critical for correct error reporting from the interpreter.
* The MORPH `tulis` (print) function has specific output formatting: a single call with multiple arguments separates them with a space (`tulis(a, b)` -> `a b`), while multiple calls print concatenated output with no separator (`tulis(a); tulis(b)` -> `ab`). String values are surrounded by double quotes, and `None` is output as `nil`.
* The Morph Netbase system is built on a Semantic Data Architecture using a Subjek-Predikat-Objek (SPO) model for its internal database.
* The `morphupgrade` (transpiler) project is obsolete and has been superseded by the `transisi` (interpreter) project. Obsolete tests related to `morphupgrade` should be archived.
* The OCaml AST `location` type defined in `universal/ast.ml` is a record `{ start_pos: position; end_pos: position; }`, where `position` is also a record `{ line: int; col: int; }`. This structure provides detailed source code position metadata.
* The MORPH lexer (`lx.py`) supports single-line comments starting with `//`.
* The communication layer for Morph Netbase (the EPN) is implemented using a simple filesystem-based 'inbox' model. Messages are encrypted and placed in a directory corresponding to the recipient's username (e.g., `netbase/jaringan/inbox/fox/`).
* A critical pattern in `ocamllex` (`.mll` files) for languages where newlines are significant is to have a rule for whitespace (`[' ' '\t' '\r']+`) that explicitly excludes newline (`\n`), and a separate rule for `\n` that returns a `NEWLINE` token. This prevents the lexer from silently consuming significant newlines.
* MORPH standard library modules can have dependencies on other standard library modules. When writing tests for a module, it may be necessary to also import its dependencies (e.g., tests for `berkas.fox` needed `panjang` from `daftar.fox`).
* To avoid environment conflicts with isolated `pipx` installations, tests must be run using `python -m pytest ...`. This ensures the test runner uses the project's active Python environment and can find all installed plugins. `pytest-subtests` is a required development dependency.
* The MORPH module system caches modules based on their absolute path. The cache now uses a FIFO eviction policy and has a configurable size via the `MORPH_MODULE_CACHE_SIZE` environment variable.
* When implementing features in the OCaml-Python bridge, a cross-language Test-Driven Development (TDD) workflow is preferred: 1. Modify the OCaml AST, parser, and JSON serializer. 2. Rebuild the OCaml compiler. 3. Write a new, failing Python test for the deserialization. 4. Implement the Python deserialization logic in `ocaml_loader.py` to make the test pass.
* The user has a strong preference for maintaining a 100% passing test suite. All pre-existing test failures should be fixed rather than ignored.
* The user provides highly detailed, structured feedback in the form of "Score Cards" and "Test Coverage Analysis" after submissions. This feedback should be treated as the plan for the next iteration of work.
* The main branch for the repository is `main`, not `master`.
* The project is a 'hybrid transpiler-interpreter' for the MORPH language, currently in a 'bootstrap MVP' phase. The current strategic priorities, based on user-provided analysis, are improving type safety, pattern matching exhaustiveness, and expanding the standard library.
* The MORPH `jika/maka/lain` (if/then/else) construct is a block statement, not an inline expression (like a ternary operator). Each clause (`maka` and `lain`) must introduce a new block, typically on a new line.
* When testing MORPH code that uses the `tulis` function for multiple outputs, a robust pattern is to have the MORPH code print a unique separator (e.g., ';'). The Python test should then `strip()` the captured output, remove the double quotes added by `tulis` using `.replace('"', '')`, and then `split()` by the separator to get a clean list of results for assertions.
* The `transisi` project is an interpreter for the MORPH programming language, following a classic architecture: Lexer (`lx.py`), Parser (`crusher.py`), AST definitions (`absolute_sntx_morph.py`), and Interpreter (`translator.py`).
* For bug fixes, the user prefers a Test-Driven Development (TDD) like workflow: 1. Write a new, failing test case that specifically reproduces the bug. 2. Implement the code fix to make the test pass. 3. Add more comprehensive tests to the affected area to improve robustness.
* The source code for the new self-hosting MORPH compiler will reside in a new top-level 'morph/' directory.
* The OCaml AST uses a type-safe `literal_value` variant (`Angka of float | Teks of string | Benar | Salah | Nil`) for constants. This ensures that numeric values are preserved as numbers throughout the OCaml-to-JSON pipeline and not prematurely converted to strings.
* The project has begun a long-term initiative to create a self-hosting compiler. This involves rewriting the Python interpreter from the 'transisi/' directory into the MORPH language itself.
* As part of the TDD workflow, it is acceptable to create temporary test files to verify a specific sprint's implementation. These temporary files can be deleted after the tests pass and the feature is considered verified.
* The Morph interpreter can be executed from the command line on a file using `python3 -m transisi.Morph <filename>`.
* The user prefers a structured, incremental, sprint-based workflow. I must adhere strictly to the scope of the agreed-upon sprint and not implement features from future sprints, even if they are related.
* A detailed roadmap exists for building a MORPH Standard Library. Development begins with Milestone v2.0, which includes the "Prioritas Wajib" (Mandatory Priority) modules (`matematik`, `waktu`, `teks`, `daftar`). These modules will be located in the `transisi/stdlib/wajib/` directory.
* In MORPH classes, properties and methods are considered private if their names start with an underscore (`_`). The interpreter enforces this privacy at runtime by raising a `KesalahanNama` on access attempts from outside the class.
* The `selama` (while) loops have an iteration limit to prevent infinite execution. The limit is configurable via the `MORPH_LOOP_LIMIT` environment variable.
* The MORPH language has a module system with keywords: `ambil_semua` (import all), `ambil_sebagian` (import specific symbols), `sebagai` (as alias), and `dari` (from).
* The project is a 'hybrid transpiler-interpreter' for the MORPH language, currently in a 'bootstrap MVP' phase. The current strategic priorities, based on user-provided analysis, are improving type safety, pattern matching exhaustiveness, and expanding the standard library.
* The user envisions a future package management system using `.fall` files for dependencies and a `star summon` command for installation.
* For security-sensitive operations like hashing and encryption, the preferred pattern is to use MORPH's `pinjam` FFI to bridge to established, secure Python libraries such as `hashlib` and `cryptography`, rather than implementing crypto algorithms in MORPH.
* The interpreter's global environment and built-in function registration logic is located in `transisi/translator.py`. The `Penerjemah` class's `__init__` method is the entry point for defining global symbols.
* The OCaml compiler executable, as defined in `universal/dune`, is named `main`. It is located at `universal/_build/default/main.exe` after a successful build.
* There is a structural mismatch between the OCaml compiler's AST for function declarations and the Python interpreter's expectations. For the interpreter to work correctly with a loaded AST, a function declaration should be represented as a `DeklarasiVariabel` node whose value is a `FungsiDeklarasi` node. This requires modifying `ocaml_loader.py` to parse `FungsiDeklarasi` within an expression context.
* When the user provides code review feedback, it must be treated as the definitive source of truth and implemented, even if it contradicts a previously completed solution.
* The current strategic priority is a multi-week roadmap for the compiler provided by the user. The prioritized phases are: Week 1 (Integrate detailed location data into the AST and error reporting), Week 2 (Fix the `jodohkan` parser and implement proper pattern types), Week 3 (Add comprehensive edge-case tests), and Week 4 (Documentation).
* When the user provides a detailed analysis from their "analyst team," it should be treated as the definitive solution to a problem, overriding any previous implementation attempts or debugging paths.
* As part of the self-hosting compiler initiative, the user wants to expand the MORPH language by adding a standard library, including modules for date/time, math, random, and package management utilities.
* The user prefers a collaborative, phased workflow: 1. Deep analysis to find the root cause. 2. A discussion of the findings to agree on the next steps. 3. Creation and execution of a plan to implement the agreed-upon solution.
* The MORPH interpreter supports method call syntax (`objek.metode(argumen)`). The parser handles this by creating a `PanggilFungsi` AST node whose callee is an `AmbilProperti` node, effectively reusing the existing function call and property access logic without needing a dedicated `PanggilMetode` AST node.
* After a major set of fixes, the user prefers to create a new, consolidated test suite (e.g., `test_high_priority_fixes.py`) to formally validate all fixes in one place.
* The FFI architecture uses an `FFIBridge` class in `transisi/ffi.py`. The `PythonObject` wrapper class was moved to its own file, `transisi/pembungkus.py`, to avoid circular import issues. The bridge maintains a cache of loaded modules.
* User prefers the naming convention `{kata_kerja}_{objek}` (e.g., `baca_file`) for standard library functions to ensure clarity and avoid ambiguity.
* The MORPH FFI does not support a 'splat' operator (e.g., `*args`). To pass a variable number of arguments from MORPH to a Python helper function, the MORPH function must pass a list, and the Python helper must be adapted to accept a list and unpack it internally (e.g., `def helper(parts): Path(*parts)`).
* The Morph Netbase feature is built on a Semantic Data Architecture using a Subjek-Predikat-Objek (SPO) model for its internal database.
* The `morphupgrade` (transpiler) project is obsolete and has been superseded by the `transisi` (interpreter) project. Obsolete tests related to `morphupgrade` should be archived.
* The OCaml lexer (`universal/lexer.mll`) supports single-line comments starting with `//` or `#`. The lexer rule for comments must consume characters up to, but not including, the subsequent newline to avoid interfering with newline-sensitive parsing.
* A new feature, "Morph Netbase", has been created. It is a self-sovereign data and communication platform built in MORPH, with its core modules located in the `netbase/` directory.
* Implementation of standard library functions that require callbacks from MORPH to Python (e.g., `filter`, `peta`, `reduksi`) has been deferred to a future task.
* The `pinjam` keyword is implemented, providing a Foreign Function Interface (FFI) to Python modules. The syntax is `pinjam "module.name" sebagai alias`.
* When the user provides a numbered list of tasks or patches, they must be executed sequentially in the specified order.
* Morph Netbase includes a storage management feature where data objects can be marked as `+` (active) for full synchronization or `-` (archived) to be kept only in local storage, conserving server/VPS resources.
* The lexer (`lx.py`) reports errors as a list of dictionaries (`[{'pesan': ..., 'baris': ..., 'kolom': ..., 'file': ...}]`).
* When the user provides example code, they distinguish between 'final implementation' code (which should be used verbatim) and 'template/guide' code (which should be adapted to the existing architecture).
* A key architectural pattern for the project is a "State Synchronization Engine". This involves a declarative, user-facing file (e.g., `netbase.json`) that defines the desired state of the system. An automated process then reconciles this desired state with an internal, structured database, applying changes (adds, updates, deletes) to match the declaration. This approach is inspired by Infrastructure-as-Code principles.
* MORPH has a built-in function `baca_json(path)` for reading and parsing JSON data files.
* The MORPH Standard Library is being built inside the `transisi/stdlib/` directory. It is structured into subdirectories based on priority (e.g., `wajib/`, `tinggi/`) as defined in the project's roadmap.
* The `pytest.ini` file is used for test configuration. Custom markers (e.g., `asyncio`, `stdlib`, `unit`, `fitur_baru`, `parser`, `lexer`, `errors`) must be registered. The `norecursedirs` option should be used to exclude directories, such as `tests/archived_tests`, from test discovery.
* The MORPH language supports 'tetap' for constant variable declarations, which are enforced at runtime to be immutable by checking for reassignment.
* When debugging, errors like `AttributeError: 'coroutine' object has no attribute '...'` or `RuntimeWarning: coroutine ... was never awaited` are strong indicators that an `async def` method was called without a preceding `await`. This is a common issue after large asynchronous refactoring.
* During the development of the self-hosting compiler, the new MORPH code in the 'morph/' directory will be executed and tested using the existing Python interpreter from the 'transisi/' directory.
* New applications or features should follow a modular design, separating concerns into distinct files or libraries (e.g., a security/crypto layer, a business logic/profile management layer, and a presentation/UI layer).
* The user may provide complete shell scripts (e.g., `test_complete.sh`) for end-to-end validation. These scripts should be created, made executable (`chmod +x`), and run to confirm functionality.
* The Python interpreter performs runtime exhaustiveness checking for `jodohkan` statements on `tipe` (discriminated union) values. If not all variants are handled and no wildcard (`_`) or variable-binding pattern is present, it raises a `KesalahanPola`.
* For complex tasks like debugging the OCaml bridge, the user prefers a highly structured, multi-phase plan. Each phase should be a distinct PR with specific patches and deliverables, and they should be executed sequentially.
* When debugging FFI-related issues, surface-level parser syntax errors (e.g., an error on an assignment keyword like `ubah`) can be misleading. The root cause is often a deeper limitation of the FFI, such as its inability to handle specific syntax (like method calls) or data types on the right-hand side of the expression.
* The Morph Netbase application has evolved into a persistent background service (`daemon.fox`) that runs in a continuous loop, using a time-based 'floodwait' timer for synchronization. The `main.fox` file is now a utility script for profile creation.
* A command-line runner script at the root of the project, named `morph_cli`, is a relic from a previous engine and is distinct from the current `transisi` interpreter and the new `morph/` compiler project.
* The Python interpreter's entry point (`transisi/Morph.py`) supports a `--use-ocaml-loader` command-line flag. When present, it bypasses the Python parser and instead loads and executes a JSON AST file provided as an argument.
* The OCaml lexer (`universal/lexer.mll`) supports single-line comments starting with `//` or `#`. The lexer rule for comments must consume characters up to, but not including, the subsequent newline to avoid interfering with newline-sensitive parsing.
* To add a new language feature to MORPH, the workflow involves updating token definitions (`morph_t.py`), the lexer (`lx.py`), the parser (`crusher.py`) to build an AST node, and the interpreter (`translator.py`) to execute that AST node.
* The repository contains multiple projects, including `fox_engine` (an async task framework) and `transisi` (interpreter). The entire codebase, including comments, variables, and documentation, is written in Bahasa Indonesia.
* Before making any changes, I must enter a 'deep planning mode'. This involves asking clarifying questions over multiple turns using `request_user_input` to achieve absolute certainty, reflecting on the user's answers to formulate new questions, and testing every assumption. The goal is to understand the user's expectations, not to get a plan approved. I will only create a plan with `set_plan` after all doubt is eliminated.
